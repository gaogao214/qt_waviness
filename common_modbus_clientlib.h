#ifndef _MODBUS_COMMON_CLIENT_DEFINITION_H_
#define _MODBUS_COMMON_CLIENT_DEFINITION_H_

/* this file has been generated by gModbus on Tue Oct 20 12:14:04 2015*/

#include "modbus_clientlib.h"



#ifndef __PACKED
#ifdef WIN32
#define __PACKED
#else
#define __PACKED __attribute__ ((packed))
#endif // WIN32
#endif // __PACKED



/* Symbolic names for register */
enum {
GETLASTCOMMANDSTATUS=0,
GETLASTCOMMANDSTATUSEX=10000,
MXCOMMON__GETMODULETYPE=1,
MXCOMMON__GETMODULETYPEEX=10200,
MXCOMMON__GETTIME=2,
MXCOMMON__GETTIMEEX=10500,
MXCOMMON__TESTCUSTOMERID=3,
MXCOMMON__TESTCUSTOMERIDEX=10550,
};

#ifdef WIN32
#pragma pack(1)
#endif // WIN32

struct GetLastCommandStatus_parameters_t
{
	uint32_t ReturnValue;
	uint32_t Syserrno;
	uint8_t Errstr[100];
 } __PACKED;

struct GetLastCommandStatusEx_parameters_t
{
	uint32_t ReturnValue;
	uint32_t Syserrno;
	uint8_t Errstr[100];
 } __PACKED;

struct MXCommon__GetModuleType_parameters_t
{
	uint8_t str[200];
 } __PACKED;

struct MXCommon__GetModuleTypeEx_parameters_t
{
	uint8_t str[200];
 } __PACKED;

struct MXCommon__GetTime_parameters_t
{
	uint32_t tv_sec;
	uint32_t tv_usec;
 } __PACKED;

struct MXCommon__GetTimeEx_parameters_t
{
	uint32_t tv_sec;
	uint32_t tv_usec;
 } __PACKED;

struct MXCommon__TestCustomerID_parameters_t
{
	uint8_t bValueArray[16];
	uint8_t bCryptedValueArray[16];
 } __PACKED;

struct MXCommon__TestCustomerIDEx_parameters_t
{
	uint8_t bValueArray[16];
	uint8_t bCryptedValueArray[16];
 } __PACKED;

#ifdef WIN32
#pragma pack()
#endif // WIN32



/** <p>Return the result of the last remote function call</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[out] <b><VAR>ReturnValue:</VAR></b> The return value of the remote function. <ul><li>0 Always means success<li> -100 means you should check Syserrno; <li>for other values, check the documentation of the function</ul></p>
* <p>@param[out] <b><VAR>Syserrno:</VAR></b> the value of the libc errno after the call to the remote function</p>
* <p>@param[out] <b><VAR>Errstr:</VAR></b> A nul-terminated string describing the error code Syserrno</p></ul>
*/
            


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_GetLastCommandStatus(struct modbus * modbus,struct GetLastCommandStatus_parameters_t * Response);



/** <p>Return the result of the last remote function call</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[out] <b><VAR>ReturnValue:</VAR></b> The return value of the remote function. <ul><li>0 Always means success<li> -100 means you should check Syserrno; <li>for other values, check the documentation of the function</ul></p>
* <p>@param[out] <b><VAR>Syserrno:</VAR></b> the value of the libc errno after the call to the remote function</p>
* <p>@param[out] <b><VAR>Errstr:</VAR></b> A nul-terminated string describing the error code Syserrno</p></ul>
*/
            


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_GetLastCommandStatusEx(struct modbus * modbus,struct GetLastCommandStatusEx_parameters_t * Response);



/** <p>Returns the type of the MSX-E Module</p>
*
* <p><b>Parameters:</b></p><ul>
* @param[out] <b><VAR>str:</VAR></b> A 200-characters string</ul>
*/
            


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MXCommon__GetModuleType(struct modbus * modbus,struct MXCommon__GetModuleType_parameters_t * Response);



/** <p>Returns the type of the MSX-E Module</p>
*
* <p><b>Parameters:</b></p><ul>
* @param[out] <b><VAR>str:</VAR></b> A 200-characters string</ul>
*/
            


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MXCommon__GetModuleTypeEx(struct modbus * modbus,struct MXCommon__GetModuleTypeEx_parameters_t * Response);



/** <p>Get the time on the module</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[out] <b><VAR>tv_sec:</VAR></b> Number of seconds since the Epoch</p>
* <p>@param[out] <b><VAR>tv_usec:</VAR></b> Number of microseconds since the begin of the second</p></ul>
*/
    


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MXCommon__GetTime(struct modbus * modbus,struct MXCommon__GetTime_parameters_t * Response);



/** <p>Get the time on the module</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[out] <b><VAR>tv_sec:</VAR></b> Number of seconds since the Epoch</p>
* <p>@param[out] <b><VAR>tv_usec:</VAR></b> Number of microseconds since the begin of the second</p></ul>
*/
    


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MXCommon__GetTimeEx(struct modbus * modbus,struct MXCommon__GetTimeEx_parameters_t * Response);



/** <p>Permit to test the Customer ID (if the module has the right customer Key )</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[out] <b><VAR>bValueArray:</VAR></b> non crypted value array [16 bytes of random data]</p>
* <p>@param[out] <b><VAR>bCryptedValueArray:</VAR></b> Crypted value array [16 bytes of the crypted random data]</p></ul>
*/
    


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MXCommon__TestCustomerID(struct modbus * modbus,struct MXCommon__TestCustomerID_parameters_t * Response);



/** <p>Permit to test the Customer ID (if the module has the right customer Key )</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[out] <b><VAR>bValueArray:</VAR></b> non crypted value array [16 bytes of random data]</p>
* <p>@param[out] <b><VAR>bCryptedValueArray:</VAR></b> Crypted value array [16 bytes of the crypted random data]</p></ul>
*/
    


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MXCommon__TestCustomerIDEx(struct modbus * modbus,struct MXCommon__TestCustomerIDEx_parameters_t * Response);


/* Symbolic names for register */
enum {
MXCOMMON__SETHARDWARETRIGGERFILTERTIME=100,
MXCOMMON__SETHARDWARETRIGGERFILTERTIMEEX=11000,
MXCOMMON__INITANDSTARTSYNCHROTIMER=101,
MXCOMMON__INITANDSTARTSYNCHROTIMEREX=11050,
MXCOMMON__STOPANDRELEASESYNCHROTIMER=102,
MXCOMMON__STOPANDRELEASESYNCHROTIMEREX=11100,
MXCOMMON__REBOOT=103,
MXCOMMON__REBOOTEX=11150,
MXCOMMON__SETCUSTOMERKEY=104,
MXCOMMON__SETCUSTOMERKEYEX=11200,
MXCOMMON__SETFILTERCHANNELS=105,
MXCOMMON__SETFILTERCHANNELSEX=11250,
};

#ifdef WIN32
#pragma pack(1)
#endif // WIN32

struct MXCommon__SetHardwareTriggerFilterTime_parameters_t
{
	uint32_t ulFilterTime;
	uint32_t Reserved;
 } __PACKED;

struct MXCommon__SetHardwareTriggerFilterTimeEx_parameters_t
{
	uint32_t ulFilterTime;
	uint32_t Reserved;
 } __PACKED;

struct MXCommon__InitAndStartSynchroTimer_parameters_t
{
	uint32_t ulTimeBase;
	uint32_t ulReloadValue;
	uint32_t ulNbrOfCycle;
	uint32_t ulGenerateTriggerMode;
	uint32_t ulOption01;
	uint32_t ulOption02;
	uint32_t ulOption03;
	uint32_t ulOption04;
 } __PACKED;

struct MXCommon__InitAndStartSynchroTimerEx_parameters_t
{
	uint32_t ulTimeBase;
	uint32_t ulReloadValue;
	uint32_t ulNbrOfCycle;
	uint32_t ulGenerateTriggerMode;
	uint32_t ulOption01;
	uint32_t ulOption02;
	uint32_t ulOption03;
	uint32_t ulOption04;
 } __PACKED;

struct MXCommon__StopAndReleaseSynchroTimer_parameters_t
{
	uint32_t ulOption01;
 } __PACKED;

struct MXCommon__StopAndReleaseSynchroTimerEx_parameters_t
{
	uint32_t ulOption01;
 } __PACKED;

struct MXCommon__Reboot_parameters_t
{
	uint32_t Dummy;
 } __PACKED;

struct MXCommon__RebootEx_parameters_t
{
	uint32_t Dummy;
 } __PACKED;

struct MXCommon__SetCustomerKey_parameters_t
{
	uint8_t bKey[32];
	uint8_t bPublicKey[16];
 } __PACKED;

struct MXCommon__SetCustomerKeyEx_parameters_t
{
	uint8_t bKey[32];
	uint8_t bPublicKey[16];
 } __PACKED;

struct MXCommon__SetFilterChannels_parameters_t
{
	uint8_t ChannelList[16];
 } __PACKED;

struct MXCommon__SetFilterChannelsEx_parameters_t
{
	uint8_t ChannelList[16];
 } __PACKED;

#ifdef WIN32
#pragma pack()
#endif // WIN32


/** <p>Sets the filter time for the hardware trigger input in <b>250ns</b> step (max value : 65535 ).</p>
* <p>On the MSX-E3011 system, the step of the hardware trigger filter is <b>622ns</b>.</p>
*
* <p><b>Parameters</b></p>
* <ul>
*   <li>@param[in] <b><VAR>ulFilterTime</VAR></b> Filter time for the hardware trigger input in 250ns step (max value : 65535 ).
*       <ul>
*           <li><b>0</b>: disable the filter</li>
*           <li><b>1</b>: filter of 250ns </li>
*           <li><b>2</b>: filter of 500ns </li>
*           <li>...</li>
*           <li><b>65535</b>: filter of 16ms</li>
*       </ul>
*   </li>
*   <li>@param[in] <b><VAR>ulOption</VAR></b> Reserved. Set to 0</li>
* </ul>
* <p><b>Returns</b></p>
* <p>Possible return value on the remote system (read them with GetLastCommandStatus).</p>
* <ul>
*   <li><b>0</b> The remote function performed OK</li>
*   <li><b>-1</b> Internal system error occurred. See value of syserrno</li>
* </ul>
*/
    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MXCommon__SetHardwareTriggerFilterTime(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulFilterTime;
	uint32_t Reserved;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MXCommon__SetHardwareTriggerFilterTime(modbus,ulFilterTime,Reserved,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MXCommon__SetHardwareTriggerFilterTime");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MXCommon__SetHardwareTriggerFilterTime\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MXCommon__SetHardwareTriggerFilterTime()\n",ret);
			return -1;
			break;
	}
	printf("call to MXCommon__SetHardwareTriggerFilterTime OK\n");
	return 0;
}

*/

int modbus_call_MXCommon__SetHardwareTriggerFilterTime(struct modbus * modbus,
	uint32_t ulFilterTime,
	uint32_t Reserved
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Sets the filter time for the hardware trigger input in <b>250ns</b> step (max value : 65535 ).</p>
* <p>On the MSX-E3011 system, the step of the hardware trigger filter is <b>622ns</b>.</p>
*
* <p><b>Parameters</b></p>
* <ul>
*   <li>@param[in] <b><VAR>ulFilterTime</VAR></b> Filter time for the hardware trigger input in 250ns step (max value : 65535 ).
*       <ul>
*           <li><b>0</b>: disable the filter</li>
*           <li><b>1</b>: filter of 250ns </li>
*           <li><b>2</b>: filter of 500ns </li>
*           <li>...</li>
*           <li><b>65535</b>: filter of 16ms</li>
*       </ul>
*   </li>
*   <li>@param[in] <b><VAR>ulOption</VAR></b> Reserved. Set to 0</li>
* </ul>
* <p><b>Returns</b></p>
* <p>Possible return value on the remote system (read them with GetLastCommandStatus).</p>
* <ul>
*   <li><b>0</b> The remote function performed OK</li>
*   <li><b>-1</b> Internal system error occurred. See value of syserrno</li>
* </ul>
*/
    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MXCommon__SetHardwareTriggerFilterTimeEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulFilterTime;
	uint32_t Reserved;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MXCommon__SetHardwareTriggerFilterTimeEx(modbus,ulFilterTime,Reserved,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MXCommon__SetHardwareTriggerFilterTimeEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MXCommon__SetHardwareTriggerFilterTimeEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MXCommon__SetHardwareTriggerFilterTimeEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MXCommon__SetHardwareTriggerFilterTimeEx OK\n");
	return 0;
}

*/

int modbus_call_MXCommon__SetHardwareTriggerFilterTimeEx(struct modbus * modbus,
	uint32_t ulFilterTime,
	uint32_t Reserved
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Init and start the synchronisation timer of the module (not already available on all module)</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[in] <b><VAR>ulTimeBase:</VAR></b> Time base of the timer (0 for us, 1 for ms, 2 for s)</p>
* <p>@param[in] <b><VAR>ulReloadValue:</VAR></b> Timer reload value (0 to 0xFFFF), minimum reload time is 5 us</p>
* <p>@param[in] <b><VAR>ulNbrOfCycle:</VAR></b> Number of timer cycle \n<ul>
*                             <li> 0: continuous
*                             <li> > 0: defined number of cycle</p>
*</ul>
* <p>@param[in] <b><VAR>ulGenerateTriggerMode:</VAR></b> \n<ul>
*                             <li> 0: Wait the time overflow to set the synchronisation trigger
*                             <li> 1: Set the synchronisation trigger by the start of the timer and after each time overflow</ul></p>
*
* <p>@param[in] <b><VAR>ulOption01:</VAR></b>Define the source of the trigger<ul>
*                             <li> 0 : Trigger disabled \n
*                             <li> 1 : Enable the hardware figital input trigger</ul></p>
* <p>@param[in] <b><VAR>ulOption02:</VAR></b>Define the edge of the hardware trigger who generates a trigger action<ul>
*                             <li> 1 : rising edge (Only if hardware trigger selected)
*                             <li> 2 : falling edge (Only if hardware trigger selected)
*                             <li> 3 : Both front (Only if hardware trigger selected)</ul></p>
* <p>@param[in] <b><VAR>ulOption03:</VAR></b>Define the number of trigger events before the action occur<ul>
*                             <li> 1 : all trigger event start the action
*                             <li> max value : 65535</ul></p>
* <p>@param[in] <b><VAR>ulOption04:</VAR></b> Reserved</p></ul>
*
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                            <li> 0 :  means the remote function performed OK
*                            <li> -1:  means an system error occured
*                            <li> -2:  not available time base
*                            <li> -3:  timer reload value can not be greater than 65535
*                            <li> -4:  minimum time reload is 5 us
*                            <li> -5:  Number of cycle can not be greater than 65535
*                            <li> -6:  Generate trigger mode error
*                            <li> -100: Init timer error
*                            <li> -101: Start timer error
* </ul></ul>
*/
    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MXCommon__InitAndStartSynchroTimer(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulTimeBase;
	uint32_t ulReloadValue;
	uint32_t ulNbrOfCycle;
	uint32_t ulGenerateTriggerMode;
	uint32_t ulOption01;
	uint32_t ulOption02;
	uint32_t ulOption03;
	uint32_t ulOption04;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MXCommon__InitAndStartSynchroTimer(modbus,ulTimeBase,ulReloadValue,ulNbrOfCycle,ulGenerateTriggerMode,ulOption01,ulOption02,ulOption03,ulOption04,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MXCommon__InitAndStartSynchroTimer");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MXCommon__InitAndStartSynchroTimer\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MXCommon__InitAndStartSynchroTimer()\n",ret);
			return -1;
			break;
	}
	printf("call to MXCommon__InitAndStartSynchroTimer OK\n");
	return 0;
}

*/

int modbus_call_MXCommon__InitAndStartSynchroTimer(struct modbus * modbus,
	uint32_t ulTimeBase,
	uint32_t ulReloadValue,
	uint32_t ulNbrOfCycle,
	uint32_t ulGenerateTriggerMode,
	uint32_t ulOption01,
	uint32_t ulOption02,
	uint32_t ulOption03,
	uint32_t ulOption04
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Init and start the synchronisation timer of the module (not already available on all module)</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[in] <b><VAR>ulTimeBase:</VAR></b> Time base of the timer (0 for us, 1 for ms, 2 for s)</p>
* <p>@param[in] <b><VAR>ulReloadValue:</VAR></b> Timer reload value (0 to 0xFFFF), minimum reload time is 5 us</p>
* <p>@param[in] <b><VAR>ulNbrOfCycle:</VAR></b> Number of timer cycle \n<ul>
*                             <li> 0: continuous
*                             <li> > 0: defined number of cycle</p>
*</ul>
* <p>@param[in] <b><VAR>ulGenerateTriggerMode:</VAR></b> \n<ul>
*                             <li> 0: Wait the time overflow to set the synchronisation trigger
*                             <li> 1: Set the synchronisation trigger by the start of the timer and after each time overflow</ul></p>
*
* <p>@param[in] <b><VAR>ulOption01:</VAR></b>Define the source of the trigger<ul>
*                             <li> 0 : Trigger disabled \n
*                             <li> 1 : Enable the hardware figital input trigger</ul></p>
* <p>@param[in] <b><VAR>ulOption02:</VAR></b>Define the edge of the hardware trigger who generates a trigger action<ul>
*                             <li> 1 : rising edge (Only if hardware trigger selected)
*                             <li> 2 : falling edge (Only if hardware trigger selected)
*                             <li> 3 : Both front (Only if hardware trigger selected)</ul></p>
* <p>@param[in] <b><VAR>ulOption03:</VAR></b>Define the number of trigger events before the action occur<ul>
*                             <li> 1 : all trigger event start the action
*                             <li> max value : 65535</ul></p>
* <p>@param[in] <b><VAR>ulOption04:</VAR></b> Reserved</p></ul>
*
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                            <li> 0 :  means the remote function performed OK
*                            <li> -1:  means an system error occured
*                            <li> -2:  not available time base
*                            <li> -3:  timer reload value can not be greater than 65535
*                            <li> -4:  minimum time reload is 5 us
*                            <li> -5:  Number of cycle can not be greater than 65535
*                            <li> -6:  Generate trigger mode error
*                            <li> -100: Init timer error
*                            <li> -101: Start timer error
* </ul></ul>
*/
    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MXCommon__InitAndStartSynchroTimerEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulTimeBase;
	uint32_t ulReloadValue;
	uint32_t ulNbrOfCycle;
	uint32_t ulGenerateTriggerMode;
	uint32_t ulOption01;
	uint32_t ulOption02;
	uint32_t ulOption03;
	uint32_t ulOption04;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MXCommon__InitAndStartSynchroTimerEx(modbus,ulTimeBase,ulReloadValue,ulNbrOfCycle,ulGenerateTriggerMode,ulOption01,ulOption02,ulOption03,ulOption04,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MXCommon__InitAndStartSynchroTimerEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MXCommon__InitAndStartSynchroTimerEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MXCommon__InitAndStartSynchroTimerEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MXCommon__InitAndStartSynchroTimerEx OK\n");
	return 0;
}

*/

int modbus_call_MXCommon__InitAndStartSynchroTimerEx(struct modbus * modbus,
	uint32_t ulTimeBase,
	uint32_t ulReloadValue,
	uint32_t ulNbrOfCycle,
	uint32_t ulGenerateTriggerMode,
	uint32_t ulOption01,
	uint32_t ulOption02,
	uint32_t ulOption03,
	uint32_t ulOption04
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>stop the synchronisation timer (not already available on all module)</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[in] <b><VAR>ulOption01</VAR></b> : Reserved</p></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                             <li> 0 :  means the remote function performed OK
*                             <li> -1:  means an system error occured
*                             <li> -100: Start/Stop timer error
* </ul></ul>
*/
    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MXCommon__StopAndReleaseSynchroTimer(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulOption01;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MXCommon__StopAndReleaseSynchroTimer(modbus,ulOption01,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MXCommon__StopAndReleaseSynchroTimer");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MXCommon__StopAndReleaseSynchroTimer\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MXCommon__StopAndReleaseSynchroTimer()\n",ret);
			return -1;
			break;
	}
	printf("call to MXCommon__StopAndReleaseSynchroTimer OK\n");
	return 0;
}

*/

int modbus_call_MXCommon__StopAndReleaseSynchroTimer(struct modbus * modbus,
	uint32_t ulOption01
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>stop the synchronisation timer (not already available on all module)</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[in] <b><VAR>ulOption01</VAR></b> : Reserved</p></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                             <li> 0 :  means the remote function performed OK
*                             <li> -1:  means an system error occured
*                             <li> -100: Start/Stop timer error
* </ul></ul>
*/
    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MXCommon__StopAndReleaseSynchroTimerEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulOption01;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MXCommon__StopAndReleaseSynchroTimerEx(modbus,ulOption01,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MXCommon__StopAndReleaseSynchroTimerEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MXCommon__StopAndReleaseSynchroTimerEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MXCommon__StopAndReleaseSynchroTimerEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MXCommon__StopAndReleaseSynchroTimerEx OK\n");
	return 0;
}

*/

int modbus_call_MXCommon__StopAndReleaseSynchroTimerEx(struct modbus * modbus,
	uint32_t ulOption01
, struct GetLastCommandStatus_parameters_t * CommandStatus);


/** <p>Ask the MSX-E module to reboot</p>
*
* <p><b>Parameters:</b></p>
* <ul>
* <p>@param[in] <b><VAR>Dummy</VAR></b> : Reserved</p>
* </ul>
*
* <p><b> Returns:</b></p><ul>
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                             <li> 0 :  means the remote function performed OK
*                             <li> -1:  means an system error occured (probably EPERM)
* </ul></ul>
*
*
*/

    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MXCommon__Reboot(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t Dummy;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MXCommon__Reboot(modbus,Dummy,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MXCommon__Reboot");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MXCommon__Reboot\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MXCommon__Reboot()\n",ret);
			return -1;
			break;
	}
	printf("call to MXCommon__Reboot OK\n");
	return 0;
}

*/

int modbus_call_MXCommon__Reboot(struct modbus * modbus,
	uint32_t Dummy
, struct GetLastCommandStatus_parameters_t * CommandStatus);


/** <p>Ask the MSX-E module to reboot</p>
*
* <p><b>Parameters:</b></p>
* <ul>
* <p>@param[in] <b><VAR>Dummy</VAR></b> : Reserved</p>
* </ul>
*
* <p><b> Returns:</b></p><ul>
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                             <li> 0 :  means the remote function performed OK
*                             <li> -1:  means an system error occured (probably EPERM)
* </ul></ul>
*
*
*/

    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MXCommon__RebootEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t Dummy;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MXCommon__RebootEx(modbus,Dummy,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MXCommon__RebootEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MXCommon__RebootEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MXCommon__RebootEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MXCommon__RebootEx OK\n");
	return 0;
}

*/

int modbus_call_MXCommon__RebootEx(struct modbus * modbus,
	uint32_t Dummy
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Permit to set the Customer key</p>
*
* <p><b>Parameters:</b></p>
* <ul>
* <p>@param[in] <b><VAR>bKey</VAR></b> : Customer key (only writable on the module) [32 bytes containing a AES key]</p>
* <p>@param[in] <b><VAR>bPublicKey</VAR></b> : IV (Initialisation vector) for the AES cryptography [16 bytes containing a AES key]</p>
* </ul>
*
* <p><b> Returns:</b></p><ul>
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                             <li> 0 :  means the remote function performed OK
*                             <li> -1:  means an system error occured (probably EPERM)
* </ul></ul>
*
*
*/
    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MXCommon__SetCustomerKey(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint8_t bKey[32];
	uint8_t bPublicKey[16];

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MXCommon__SetCustomerKey(modbus,bKey,bPublicKey,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MXCommon__SetCustomerKey");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MXCommon__SetCustomerKey\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MXCommon__SetCustomerKey()\n",ret);
			return -1;
			break;
	}
	printf("call to MXCommon__SetCustomerKey OK\n");
	return 0;
}

*/

int modbus_call_MXCommon__SetCustomerKey(struct modbus * modbus,
	uint8_t bKey[32],
	uint8_t bPublicKey[16]
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Permit to set the Customer key</p>
*
* <p><b>Parameters:</b></p>
* <ul>
* <p>@param[in] <b><VAR>bKey</VAR></b> : Customer key (only writable on the module) [32 bytes containing a AES key]</p>
* <p>@param[in] <b><VAR>bPublicKey</VAR></b> : IV (Initialisation vector) for the AES cryptography [16 bytes containing a AES key]</p>
* </ul>
*
* <p><b> Returns:</b></p><ul>
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                             <li> 0 :  means the remote function performed OK
*                             <li> -1:  means an system error occured (probably EPERM)
* </ul></ul>
*
*
*/
    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MXCommon__SetCustomerKeyEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint8_t bKey[32];
	uint8_t bPublicKey[16];

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MXCommon__SetCustomerKeyEx(modbus,bKey,bPublicKey,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MXCommon__SetCustomerKeyEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MXCommon__SetCustomerKeyEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MXCommon__SetCustomerKeyEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MXCommon__SetCustomerKeyEx OK\n");
	return 0;
}

*/

int modbus_call_MXCommon__SetCustomerKeyEx(struct modbus * modbus,
	uint8_t bKey[32],
	uint8_t bPublicKey[16]
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Permit to set a filter per channel</p>
*
* <p><b>Parameters:</b></p>
* <ul>
* <p>@param[in] <b><VAR>ChannelList</VAR></b> : Each index of the array is representing a channel. To set a filter on a channel, enter the filter ID. By default the value ist 0 (No filter).</p>
* </ul>
*
* <p><b> Returns:</b></p><ul>
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                             <li> 0 :  means the remote function performed OK
*                             <li> -1:  means a system error occurred (probably EPERM)
* </ul></ul>
*
*
*/
    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MXCommon__SetFilterChannels(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint8_t ChannelList[16];

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MXCommon__SetFilterChannels(modbus,ChannelList,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MXCommon__SetFilterChannels");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MXCommon__SetFilterChannels\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MXCommon__SetFilterChannels()\n",ret);
			return -1;
			break;
	}
	printf("call to MXCommon__SetFilterChannels OK\n");
	return 0;
}

*/

int modbus_call_MXCommon__SetFilterChannels(struct modbus * modbus,
	uint8_t ChannelList[16]
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Permit to set a filter per channel</p>
*
* <p><b>Parameters:</b></p>
* <ul>
* <p>@param[in] <b><VAR>ChannelList</VAR></b> : Each index of the array is representing a channel. To set a filter on a channel, enter the filter ID. By default the value ist 0 (No filter).</p>
* </ul>
*
* <p><b> Returns:</b></p><ul>
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                             <li> 0 :  means the remote function performed OK
*                             <li> -1:  means a system error occurred (probably EPERM)
* </ul></ul>
*
*
*/
    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MXCommon__SetFilterChannelsEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint8_t ChannelList[16];

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MXCommon__SetFilterChannelsEx(modbus,ChannelList,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MXCommon__SetFilterChannelsEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MXCommon__SetFilterChannelsEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MXCommon__SetFilterChannelsEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MXCommon__SetFilterChannelsEx OK\n");
	return 0;
}

*/

int modbus_call_MXCommon__SetFilterChannelsEx(struct modbus * modbus,
	uint8_t ChannelList[16]
, struct GetLastCommandStatus_parameters_t * CommandStatus);

#endif //_MODBUS_MSXE371X_CLIENT_DEFINITION_H_


