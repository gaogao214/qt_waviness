/* this file has been generated by gModbus on Tue Oct 20 12:14:04 2015 */

#ifndef _THREAD_SAFE
#define _THREAD_SAFE
#endif
#include "common_modbus_clientlib.h"

int modbus_call_GetLastCommandStatus(struct modbus * modbus,struct GetLastCommandStatus_parameters_t * Response)
{
	int ret = 0;

	ret = modbus_send_FC3_query(modbus, 0, 0, Response, sizeof( struct GetLastCommandStatus_parameters_t) );

	/* return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect */
	/* error ? */
	if(ret) return ret;

	/* convert data from network to host format */
	{
		Response->ReturnValue = MODBUS_HTONL(Response->ReturnValue);

		Response->Syserrno = MODBUS_HTONL(Response->Syserrno);

	}

	return 0;
}
int modbus_call_GetLastCommandStatusEx(struct modbus * modbus,struct GetLastCommandStatusEx_parameters_t * Response)
{
	int ret = 0;

	ret = modbus_send_FC3_query(modbus, 0, 10000, Response, sizeof( struct GetLastCommandStatusEx_parameters_t) );

	/* return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect */
	/* error ? */
	if(ret) return ret;

	/* convert data from network to host format */
	{
		Response->ReturnValue = MODBUS_HTONL(Response->ReturnValue);

		Response->Syserrno = MODBUS_HTONL(Response->Syserrno);

	}

	return 0;
}
int modbus_call_MXCommon__GetModuleType(struct modbus * modbus,struct MXCommon__GetModuleType_parameters_t * Response)
{
	int ret = 0;

	ret = modbus_send_FC3_query(modbus, 0, 1, Response, sizeof( struct MXCommon__GetModuleType_parameters_t) );

	/* return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect */
	/* error ? */
	if(ret) return ret;


	return 0;
}
int modbus_call_MXCommon__GetModuleTypeEx(struct modbus * modbus,struct MXCommon__GetModuleTypeEx_parameters_t * Response)
{
	int ret = 0;

	ret = modbus_send_FC3_query(modbus, 0, 10200, Response, sizeof( struct MXCommon__GetModuleTypeEx_parameters_t) );

	/* return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect */
	/* error ? */
	if(ret) return ret;


	return 0;
}
int modbus_call_MXCommon__GetTime(struct modbus * modbus,struct MXCommon__GetTime_parameters_t * Response)
{
	int ret = 0;

	ret = modbus_send_FC3_query(modbus, 0, 2, Response, sizeof( struct MXCommon__GetTime_parameters_t) );

	/* return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect */
	/* error ? */
	if(ret) return ret;

	/* convert data from network to host format */
	{
		Response->tv_sec = MODBUS_HTONL(Response->tv_sec);

		Response->tv_usec = MODBUS_HTONL(Response->tv_usec);

	}

	return 0;
}
int modbus_call_MXCommon__GetTimeEx(struct modbus * modbus,struct MXCommon__GetTimeEx_parameters_t * Response)
{
	int ret = 0;

	ret = modbus_send_FC3_query(modbus, 0, 10500, Response, sizeof( struct MXCommon__GetTimeEx_parameters_t) );

	/* return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect */
	/* error ? */
	if(ret) return ret;

	/* convert data from network to host format */
	{
		Response->tv_sec = MODBUS_HTONL(Response->tv_sec);

		Response->tv_usec = MODBUS_HTONL(Response->tv_usec);

	}

	return 0;
}
int modbus_call_MXCommon__TestCustomerID(struct modbus * modbus,struct MXCommon__TestCustomerID_parameters_t * Response)
{
	int ret = 0;

	ret = modbus_send_FC3_query(modbus, 0, 3, Response, sizeof( struct MXCommon__TestCustomerID_parameters_t) );

	/* return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect */
	/* error ? */
	if(ret) return ret;


	return 0;
}
int modbus_call_MXCommon__TestCustomerIDEx(struct modbus * modbus,struct MXCommon__TestCustomerIDEx_parameters_t * Response)
{
	int ret = 0;

	ret = modbus_send_FC3_query(modbus, 0, 10550, Response, sizeof( struct MXCommon__TestCustomerIDEx_parameters_t) );

	/* return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect */
	/* error ? */
	if(ret) return ret;


	return 0;
}
int modbus_call_MXCommon__SetHardwareTriggerFilterTime(struct modbus * modbus,
	uint32_t ulFilterTime,
	uint32_t Reserved,
	struct GetLastCommandStatus_parameters_t * CommandStatus)
{
	struct MXCommon__SetHardwareTriggerFilterTime_parameters_t params;

	MODBUS_DBG("%s",__FUNCTION__);

	memset(CommandStatus,0,sizeof(struct GetLastCommandStatus_parameters_t));

	/* store parameters in structure */
	params.ulFilterTime = MODBUS_NTOHL(ulFilterTime);
	MODBUS_DBG("ulFilterTime=%u\n",(uint32_t)MODBUS_NTOHL(params.ulFilterTime));
	params.Reserved = MODBUS_NTOHL(Reserved);
	MODBUS_DBG("Reserved=%u\n",(uint32_t)MODBUS_NTOHL(params.Reserved));
	
	/* call generic FC16 function */
	{
		int ret; /* return value */
		ret = modbus_send_FC16_query(modbus, 100,0, (char*) &params, sizeof(params));
		switch(ret)
		{
			case 0: /* OK */
			case -1: /* local system error (in errno) */
			case -3: /* incorrect response from remote system */
				return ret;
			case -2: /* MODBUS exception */
			{
				if (modbus->exception != MODBUS_REMOTE_EXECUTION_ERROR ) return ret;
				/* try to get the cause */
				switch(modbus_call_GetLastCommandStatus(modbus,CommandStatus))
				{
					case 0: /*  OK - user can use CommandStatus */
						return ret;
					default: /*  We are in trouble */
						return -4;
				}
			}
			default: /* internal error */
				MODBUS_ON_INTERNAL_ERROR();
		}
	}
}
int modbus_call_MXCommon__SetHardwareTriggerFilterTimeEx(struct modbus * modbus,
	uint32_t ulFilterTime,
	uint32_t Reserved,
	struct GetLastCommandStatus_parameters_t * CommandStatus)
{
	struct MXCommon__SetHardwareTriggerFilterTimeEx_parameters_t params;

	MODBUS_DBG("%s",__FUNCTION__);

	memset(CommandStatus,0,sizeof(struct GetLastCommandStatus_parameters_t));

	/* store parameters in structure */
	params.ulFilterTime = MODBUS_NTOHL(ulFilterTime);
	MODBUS_DBG("ulFilterTime=%u\n",(uint32_t)MODBUS_NTOHL(params.ulFilterTime));
	params.Reserved = MODBUS_NTOHL(Reserved);
	MODBUS_DBG("Reserved=%u\n",(uint32_t)MODBUS_NTOHL(params.Reserved));
	
	/* call generic FC16 function */
	{
		int ret; /* return value */
		ret = modbus_send_FC16_query(modbus, 11000,0, (char*) &params, sizeof(params));
		switch(ret)
		{
			case 0: /* OK */
			case -1: /* local system error (in errno) */
			case -3: /* incorrect response from remote system */
				return ret;
			case -2: /* MODBUS exception */
			{
				if (modbus->exception != MODBUS_REMOTE_EXECUTION_ERROR ) return ret;
				/* try to get the cause */
				switch(modbus_call_GetLastCommandStatus(modbus,CommandStatus))
				{
					case 0: /*  OK - user can use CommandStatus */
						return ret;
					default: /*  We are in trouble */
						return -4;
				}
			}
			default: /* internal error */
				MODBUS_ON_INTERNAL_ERROR();
		}
	}
}
int modbus_call_MXCommon__InitAndStartSynchroTimer(struct modbus * modbus,
	uint32_t ulTimeBase,
	uint32_t ulReloadValue,
	uint32_t ulNbrOfCycle,
	uint32_t ulGenerateTriggerMode,
	uint32_t ulOption01,
	uint32_t ulOption02,
	uint32_t ulOption03,
	uint32_t ulOption04,
	struct GetLastCommandStatus_parameters_t * CommandStatus)
{
	struct MXCommon__InitAndStartSynchroTimer_parameters_t params;

	MODBUS_DBG("%s",__FUNCTION__);

	memset(CommandStatus,0,sizeof(struct GetLastCommandStatus_parameters_t));

	/* store parameters in structure */
	params.ulTimeBase = MODBUS_NTOHL(ulTimeBase);
	MODBUS_DBG("ulTimeBase=%u\n",(uint32_t)MODBUS_NTOHL(params.ulTimeBase));
	params.ulReloadValue = MODBUS_NTOHL(ulReloadValue);
	MODBUS_DBG("ulReloadValue=%u\n",(uint32_t)MODBUS_NTOHL(params.ulReloadValue));
	params.ulNbrOfCycle = MODBUS_NTOHL(ulNbrOfCycle);
	MODBUS_DBG("ulNbrOfCycle=%u\n",(uint32_t)MODBUS_NTOHL(params.ulNbrOfCycle));
	params.ulGenerateTriggerMode = MODBUS_NTOHL(ulGenerateTriggerMode);
	MODBUS_DBG("ulGenerateTriggerMode=%u\n",(uint32_t)MODBUS_NTOHL(params.ulGenerateTriggerMode));
	params.ulOption01 = MODBUS_NTOHL(ulOption01);
	MODBUS_DBG("ulOption01=%u\n",(uint32_t)MODBUS_NTOHL(params.ulOption01));
	params.ulOption02 = MODBUS_NTOHL(ulOption02);
	MODBUS_DBG("ulOption02=%u\n",(uint32_t)MODBUS_NTOHL(params.ulOption02));
	params.ulOption03 = MODBUS_NTOHL(ulOption03);
	MODBUS_DBG("ulOption03=%u\n",(uint32_t)MODBUS_NTOHL(params.ulOption03));
	params.ulOption04 = MODBUS_NTOHL(ulOption04);
	MODBUS_DBG("ulOption04=%u\n",(uint32_t)MODBUS_NTOHL(params.ulOption04));
	
	/* call generic FC16 function */
	{
		int ret; /* return value */
		ret = modbus_send_FC16_query(modbus, 101,0, (char*) &params, sizeof(params));
		switch(ret)
		{
			case 0: /* OK */
			case -1: /* local system error (in errno) */
			case -3: /* incorrect response from remote system */
				return ret;
			case -2: /* MODBUS exception */
			{
				if (modbus->exception != MODBUS_REMOTE_EXECUTION_ERROR ) return ret;
				/* try to get the cause */
				switch(modbus_call_GetLastCommandStatus(modbus,CommandStatus))
				{
					case 0: /*  OK - user can use CommandStatus */
						return ret;
					default: /*  We are in trouble */
						return -4;
				}
			}
			default: /* internal error */
				MODBUS_ON_INTERNAL_ERROR();
		}
	}
}
int modbus_call_MXCommon__InitAndStartSynchroTimerEx(struct modbus * modbus,
	uint32_t ulTimeBase,
	uint32_t ulReloadValue,
	uint32_t ulNbrOfCycle,
	uint32_t ulGenerateTriggerMode,
	uint32_t ulOption01,
	uint32_t ulOption02,
	uint32_t ulOption03,
	uint32_t ulOption04,
	struct GetLastCommandStatus_parameters_t * CommandStatus)
{
	struct MXCommon__InitAndStartSynchroTimerEx_parameters_t params;

	MODBUS_DBG("%s",__FUNCTION__);

	memset(CommandStatus,0,sizeof(struct GetLastCommandStatus_parameters_t));

	/* store parameters in structure */
	params.ulTimeBase = MODBUS_NTOHL(ulTimeBase);
	MODBUS_DBG("ulTimeBase=%u\n",(uint32_t)MODBUS_NTOHL(params.ulTimeBase));
	params.ulReloadValue = MODBUS_NTOHL(ulReloadValue);
	MODBUS_DBG("ulReloadValue=%u\n",(uint32_t)MODBUS_NTOHL(params.ulReloadValue));
	params.ulNbrOfCycle = MODBUS_NTOHL(ulNbrOfCycle);
	MODBUS_DBG("ulNbrOfCycle=%u\n",(uint32_t)MODBUS_NTOHL(params.ulNbrOfCycle));
	params.ulGenerateTriggerMode = MODBUS_NTOHL(ulGenerateTriggerMode);
	MODBUS_DBG("ulGenerateTriggerMode=%u\n",(uint32_t)MODBUS_NTOHL(params.ulGenerateTriggerMode));
	params.ulOption01 = MODBUS_NTOHL(ulOption01);
	MODBUS_DBG("ulOption01=%u\n",(uint32_t)MODBUS_NTOHL(params.ulOption01));
	params.ulOption02 = MODBUS_NTOHL(ulOption02);
	MODBUS_DBG("ulOption02=%u\n",(uint32_t)MODBUS_NTOHL(params.ulOption02));
	params.ulOption03 = MODBUS_NTOHL(ulOption03);
	MODBUS_DBG("ulOption03=%u\n",(uint32_t)MODBUS_NTOHL(params.ulOption03));
	params.ulOption04 = MODBUS_NTOHL(ulOption04);
	MODBUS_DBG("ulOption04=%u\n",(uint32_t)MODBUS_NTOHL(params.ulOption04));
	
	/* call generic FC16 function */
	{
		int ret; /* return value */
		ret = modbus_send_FC16_query(modbus, 11050,0, (char*) &params, sizeof(params));
		switch(ret)
		{
			case 0: /* OK */
			case -1: /* local system error (in errno) */
			case -3: /* incorrect response from remote system */
				return ret;
			case -2: /* MODBUS exception */
			{
				if (modbus->exception != MODBUS_REMOTE_EXECUTION_ERROR ) return ret;
				/* try to get the cause */
				switch(modbus_call_GetLastCommandStatus(modbus,CommandStatus))
				{
					case 0: /*  OK - user can use CommandStatus */
						return ret;
					default: /*  We are in trouble */
						return -4;
				}
			}
			default: /* internal error */
				MODBUS_ON_INTERNAL_ERROR();
		}
	}
}
int modbus_call_MXCommon__StopAndReleaseSynchroTimer(struct modbus * modbus,
	uint32_t ulOption01,
	struct GetLastCommandStatus_parameters_t * CommandStatus)
{
	struct MXCommon__StopAndReleaseSynchroTimer_parameters_t params;

	MODBUS_DBG("%s",__FUNCTION__);

	memset(CommandStatus,0,sizeof(struct GetLastCommandStatus_parameters_t));

	/* store parameters in structure */
	params.ulOption01 = MODBUS_NTOHL(ulOption01);
	MODBUS_DBG("ulOption01=%u\n",(uint32_t)MODBUS_NTOHL(params.ulOption01));
	
	/* call generic FC16 function */
	{
		int ret; /* return value */
		ret = modbus_send_FC16_query(modbus, 102,0, (char*) &params, sizeof(params));
		switch(ret)
		{
			case 0: /* OK */
			case -1: /* local system error (in errno) */
			case -3: /* incorrect response from remote system */
				return ret;
			case -2: /* MODBUS exception */
			{
				if (modbus->exception != MODBUS_REMOTE_EXECUTION_ERROR ) return ret;
				/* try to get the cause */
				switch(modbus_call_GetLastCommandStatus(modbus,CommandStatus))
				{
					case 0: /*  OK - user can use CommandStatus */
						return ret;
					default: /*  We are in trouble */
						return -4;
				}
			}
			default: /* internal error */
				MODBUS_ON_INTERNAL_ERROR();
		}
	}
}
int modbus_call_MXCommon__StopAndReleaseSynchroTimerEx(struct modbus * modbus,
	uint32_t ulOption01,
	struct GetLastCommandStatus_parameters_t * CommandStatus)
{
	struct MXCommon__StopAndReleaseSynchroTimerEx_parameters_t params;

	MODBUS_DBG("%s",__FUNCTION__);

	memset(CommandStatus,0,sizeof(struct GetLastCommandStatus_parameters_t));

	/* store parameters in structure */
	params.ulOption01 = MODBUS_NTOHL(ulOption01);
	MODBUS_DBG("ulOption01=%u\n",(uint32_t)MODBUS_NTOHL(params.ulOption01));
	
	/* call generic FC16 function */
	{
		int ret; /* return value */
		ret = modbus_send_FC16_query(modbus, 11100,0, (char*) &params, sizeof(params));
		switch(ret)
		{
			case 0: /* OK */
			case -1: /* local system error (in errno) */
			case -3: /* incorrect response from remote system */
				return ret;
			case -2: /* MODBUS exception */
			{
				if (modbus->exception != MODBUS_REMOTE_EXECUTION_ERROR ) return ret;
				/* try to get the cause */
				switch(modbus_call_GetLastCommandStatus(modbus,CommandStatus))
				{
					case 0: /*  OK - user can use CommandStatus */
						return ret;
					default: /*  We are in trouble */
						return -4;
				}
			}
			default: /* internal error */
				MODBUS_ON_INTERNAL_ERROR();
		}
	}
}
int modbus_call_MXCommon__Reboot(struct modbus * modbus,
	uint32_t Dummy,
	struct GetLastCommandStatus_parameters_t * CommandStatus)
{
	struct MXCommon__Reboot_parameters_t params;

	MODBUS_DBG("%s",__FUNCTION__);

	memset(CommandStatus,0,sizeof(struct GetLastCommandStatus_parameters_t));

	/* store parameters in structure */
	params.Dummy = MODBUS_NTOHL(Dummy);
	MODBUS_DBG("Dummy=%u\n",(uint32_t)MODBUS_NTOHL(params.Dummy));
	
	/* call generic FC16 function */
	{
		int ret; /* return value */
		ret = modbus_send_FC16_query(modbus, 103,0, (char*) &params, sizeof(params));
		switch(ret)
		{
			case 0: /* OK */
			case -1: /* local system error (in errno) */
			case -3: /* incorrect response from remote system */
				return ret;
			case -2: /* MODBUS exception */
			{
				if (modbus->exception != MODBUS_REMOTE_EXECUTION_ERROR ) return ret;
				/* try to get the cause */
				switch(modbus_call_GetLastCommandStatus(modbus,CommandStatus))
				{
					case 0: /*  OK - user can use CommandStatus */
						return ret;
					default: /*  We are in trouble */
						return -4;
				}
			}
			default: /* internal error */
				MODBUS_ON_INTERNAL_ERROR();
		}
	}
}
int modbus_call_MXCommon__RebootEx(struct modbus * modbus,
	uint32_t Dummy,
	struct GetLastCommandStatus_parameters_t * CommandStatus)
{
	struct MXCommon__RebootEx_parameters_t params;

	MODBUS_DBG("%s",__FUNCTION__);

	memset(CommandStatus,0,sizeof(struct GetLastCommandStatus_parameters_t));

	/* store parameters in structure */
	params.Dummy = MODBUS_NTOHL(Dummy);
	MODBUS_DBG("Dummy=%u\n",(uint32_t)MODBUS_NTOHL(params.Dummy));
	
	/* call generic FC16 function */
	{
		int ret; /* return value */
		ret = modbus_send_FC16_query(modbus, 11150,0, (char*) &params, sizeof(params));
		switch(ret)
		{
			case 0: /* OK */
			case -1: /* local system error (in errno) */
			case -3: /* incorrect response from remote system */
				return ret;
			case -2: /* MODBUS exception */
			{
				if (modbus->exception != MODBUS_REMOTE_EXECUTION_ERROR ) return ret;
				/* try to get the cause */
				switch(modbus_call_GetLastCommandStatus(modbus,CommandStatus))
				{
					case 0: /*  OK - user can use CommandStatus */
						return ret;
					default: /*  We are in trouble */
						return -4;
				}
			}
			default: /* internal error */
				MODBUS_ON_INTERNAL_ERROR();
		}
	}
}
int modbus_call_MXCommon__SetCustomerKey(struct modbus * modbus,
	uint8_t bKey[32],
	uint8_t bPublicKey[16],
	struct GetLastCommandStatus_parameters_t * CommandStatus)
{
	struct MXCommon__SetCustomerKey_parameters_t params;

	MODBUS_DBG("%s",__FUNCTION__);

	memset(CommandStatus,0,sizeof(struct GetLastCommandStatus_parameters_t));

	/* store parameters in structure */
	memcpy(&(params.bKey),bKey,32);
	#ifdef _DEBUG
		{ int k; for(k=0;k<32;k++) MODBUS_DBG("bKey[%d]=%hhX\n",k,params.bKey[k]); }
	#endif
	memcpy(&(params.bPublicKey),bPublicKey,16);
	#ifdef _DEBUG
		{ int k; for(k=0;k<16;k++) MODBUS_DBG("bPublicKey[%d]=%hhX\n",k,params.bPublicKey[k]); }
	#endif
	
	/* call generic FC16 function */
	{
		int ret; /* return value */
		ret = modbus_send_FC16_query(modbus, 104,0, (char*) &params, sizeof(params));
		switch(ret)
		{
			case 0: /* OK */
			case -1: /* local system error (in errno) */
			case -3: /* incorrect response from remote system */
				return ret;
			case -2: /* MODBUS exception */
			{
				if (modbus->exception != MODBUS_REMOTE_EXECUTION_ERROR ) return ret;
				/* try to get the cause */
				switch(modbus_call_GetLastCommandStatus(modbus,CommandStatus))
				{
					case 0: /*  OK - user can use CommandStatus */
						return ret;
					default: /*  We are in trouble */
						return -4;
				}
			}
			default: /* internal error */
				MODBUS_ON_INTERNAL_ERROR();
		}
	}
}
int modbus_call_MXCommon__SetCustomerKeyEx(struct modbus * modbus,
	uint8_t bKey[32],
	uint8_t bPublicKey[16],
	struct GetLastCommandStatus_parameters_t * CommandStatus)
{
	struct MXCommon__SetCustomerKeyEx_parameters_t params;

	MODBUS_DBG("%s",__FUNCTION__);

	memset(CommandStatus,0,sizeof(struct GetLastCommandStatus_parameters_t));

	/* store parameters in structure */
	memcpy(&(params.bKey),bKey,32);
	#ifdef _DEBUG
		{ int k; for(k=0;k<32;k++) MODBUS_DBG("bKey[%d]=%hhX\n",k,params.bKey[k]); }
	#endif
	memcpy(&(params.bPublicKey),bPublicKey,16);
	#ifdef _DEBUG
		{ int k; for(k=0;k<16;k++) MODBUS_DBG("bPublicKey[%d]=%hhX\n",k,params.bPublicKey[k]); }
	#endif
	
	/* call generic FC16 function */
	{
		int ret; /* return value */
		ret = modbus_send_FC16_query(modbus, 11200,0, (char*) &params, sizeof(params));
		switch(ret)
		{
			case 0: /* OK */
			case -1: /* local system error (in errno) */
			case -3: /* incorrect response from remote system */
				return ret;
			case -2: /* MODBUS exception */
			{
				if (modbus->exception != MODBUS_REMOTE_EXECUTION_ERROR ) return ret;
				/* try to get the cause */
				switch(modbus_call_GetLastCommandStatus(modbus,CommandStatus))
				{
					case 0: /*  OK - user can use CommandStatus */
						return ret;
					default: /*  We are in trouble */
						return -4;
				}
			}
			default: /* internal error */
				MODBUS_ON_INTERNAL_ERROR();
		}
	}
}
int modbus_call_MXCommon__SetFilterChannels(struct modbus * modbus,
	uint8_t ChannelList[16],
	struct GetLastCommandStatus_parameters_t * CommandStatus)
{
	struct MXCommon__SetFilterChannels_parameters_t params;

	MODBUS_DBG("%s",__FUNCTION__);

	memset(CommandStatus,0,sizeof(struct GetLastCommandStatus_parameters_t));

	/* store parameters in structure */
	memcpy(&(params.ChannelList),ChannelList,16);
	#ifdef _DEBUG
		{ int k; for(k=0;k<16;k++) MODBUS_DBG("ChannelList[%d]=%hhX\n",k,params.ChannelList[k]); }
	#endif
	
	/* call generic FC16 function */
	{
		int ret; /* return value */
		ret = modbus_send_FC16_query(modbus, 105,0, (char*) &params, sizeof(params));
		switch(ret)
		{
			case 0: /* OK */
			case -1: /* local system error (in errno) */
			case -3: /* incorrect response from remote system */
				return ret;
			case -2: /* MODBUS exception */
			{
				if (modbus->exception != MODBUS_REMOTE_EXECUTION_ERROR ) return ret;
				/* try to get the cause */
				switch(modbus_call_GetLastCommandStatus(modbus,CommandStatus))
				{
					case 0: /*  OK - user can use CommandStatus */
						return ret;
					default: /*  We are in trouble */
						return -4;
				}
			}
			default: /* internal error */
				MODBUS_ON_INTERNAL_ERROR();
		}
	}
}
int modbus_call_MXCommon__SetFilterChannelsEx(struct modbus * modbus,
	uint8_t ChannelList[16],
	struct GetLastCommandStatus_parameters_t * CommandStatus)
{
	struct MXCommon__SetFilterChannelsEx_parameters_t params;

	MODBUS_DBG("%s",__FUNCTION__);

	memset(CommandStatus,0,sizeof(struct GetLastCommandStatus_parameters_t));

	/* store parameters in structure */
	memcpy(&(params.ChannelList),ChannelList,16);
	#ifdef _DEBUG
		{ int k; for(k=0;k<16;k++) MODBUS_DBG("ChannelList[%d]=%hhX\n",k,params.ChannelList[k]); }
	#endif
	
	/* call generic FC16 function */
	{
		int ret; /* return value */
		ret = modbus_send_FC16_query(modbus, 11250,0, (char*) &params, sizeof(params));
		switch(ret)
		{
			case 0: /* OK */
			case -1: /* local system error (in errno) */
			case -3: /* incorrect response from remote system */
				return ret;
			case -2: /* MODBUS exception */
			{
				if (modbus->exception != MODBUS_REMOTE_EXECUTION_ERROR ) return ret;
				/* try to get the cause */
				switch(modbus_call_GetLastCommandStatus(modbus,CommandStatus))
				{
					case 0: /*  OK - user can use CommandStatus */
						return ret;
					default: /*  We are in trouble */
						return -4;
				}
			}
			default: /* internal error */
				MODBUS_ON_INTERNAL_ERROR();
		}
	}
}


