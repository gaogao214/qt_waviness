#ifndef _MODBUS_MSXE371X_CLIENT_DEFINITION_H_
#define _MODBUS_MSXE371X_CLIENT_DEFINITION_H_

/* this file has been generated by gModbus on Tue Oct 20 12:14:04 2015*/

#include "common_modbus_clientlib.h"



/* Symbolic names for register */
enum {
MX371X__GETNUMBEROFCHANNELS=100,
MX371X__GETNUMBEROFCHANNELSEX=1000,
MX371X__TRANSDUCERGETAUTOREFRESHVALUES=101,
MX371X__TRANSDUCERGETAUTOREFRESHVALUESEX=1050,
MSXE371X__EXTERNALTEMPERATUREREAD=102,
MSXE371X__EXTERNALTEMPERATUREREADEX=1200,
MX371X__TRANSDUCERGETNBROFTYPE=103,
MX371X__TRANSDUCERGETNBROFTYPEEX=1212,
MX371X__GETTRANSDUCERDATABASECURSOR=104,
MX371X__GETTRANSDUCERDATABASECURSOREX=1216,
MX371X__TRANSDUCERGETTYPEINFORMATION=105,
MX371X__TRANSDUCERGETTYPEINFORMATIONEX=1220,
MX371X__TRANSDUCERINITPRIMARYCONNECTIONTEST=106,
MX371X__TRANSDUCERINITPRIMARYCONNECTIONTESTEX=1218,
MX371X__TRANSDUCERTESTPRIMARYCONNECTION=107,
MX371X__TRANSDUCERTESTPRIMARYCONNECTIONEX=1222,
MX371X__TRANSDUCERTESTPRIMARYSHORTCIRCUIT=108,
MX371X__TRANSDUCERTESTPRIMARYSHORTCIRCUITEX=1224,
MX371X__TRANSDUCERREARMPRIMARY=109,
MX371X__TRANSDUCERREARMPRIMARYEX=1226,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION0=110,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION0EX=1228,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION1=111,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION1EX=1230,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION2=112,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION2EX=1232,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION3=113,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION3EX=1234,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION4=114,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION4EX=1236,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION5=115,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION5EX=1238,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION6=116,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION6EX=1240,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION7=117,
MX371X__TRANSDUCERTESTSECONDARYCONNECTION7EX=1242,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT0=118,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT0EX=1244,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT1=119,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT1EX=1246,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT2=120,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT2EX=1248,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT3=121,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT3EX=1250,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT4=122,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT4EX=1252,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT5=123,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT5EX=1254,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT6=124,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT6EX=1256,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT7=125,
MX371X__TRANSDUCERTESTSECONDARYSHORTCIRCUIT7EX=1258,
MSXE371X__INTERNALTEMPERATUREREAD=126,
MSXE371X__INTERNALTEMPERATUREREADEX=1260,
MSXE371X__INCCOUNTERREAD32BITVALUE=1600,
};

#ifdef WIN32
#pragma pack(1)
#endif // WIN32

struct MX371x__getNumberOfChannels_parameters_t
{
	uint32_t ChannelNumber;
 } __PACKED;

struct MX371x__getNumberOfChannelsEx_parameters_t
{
	uint32_t ChannelNumber;
 } __PACKED;

struct MX371x__TransducerGetAutoRefreshValues_parameters_t
{
	uint32_t Value[17];
 } __PACKED;

struct MX371x__TransducerGetAutoRefreshValuesEx_parameters_t
{
	uint32_t Value[17];
 } __PACKED;

struct MSXE371x__ExternalTemperatureRead_parameters_t
{
	uint32_t Value;
	uint32_t TimeStampLow;
	uint32_t TimeStampHigh;
 } __PACKED;

struct MSXE371x__ExternalTemperatureReadEx_parameters_t
{
	uint32_t Value;
	uint32_t TimeStampLow;
	uint32_t TimeStampHigh;
 } __PACKED;

struct MX371x__TransducerGetNbrOfType_parameters_t
{
	uint32_t NumberOfTransducerTypes;
 } __PACKED;

struct MX371x__TransducerGetNbrOfTypeEx_parameters_t
{
	uint32_t NumberOfTransducerTypes;
 } __PACKED;

struct MX371x__GetTransducerDatabaseCursor_parameters_t
{
	uint32_t TransducerDatabaseCursor;
 } __PACKED;

struct MX371x__GetTransducerDatabaseCursorEx_parameters_t
{
	uint32_t TransducerDatabaseCursor;
 } __PACKED;

struct MX371x__TransducerGetTypeInformation_parameters_t
{
	uint32_t SelectionIndex;
	uint8_t Name[100];
	uint8_t CalibrationStatus;
	uint32_t CalibratedChannels;
	uint32_t Type;
	uint32_t Frequency;
	uint32_t Impedance;
	float NominalVoltage;
	float Sensibility;
	float Range;
 } __PACKED;

struct MX371x__TransducerGetTypeInformationEx_parameters_t
{
	uint32_t SelectionIndex;
	uint8_t Name[100];
	uint8_t CalibrationStatus;
	uint32_t CalibratedChannels;
	uint32_t Type;
	uint32_t Frequency;
	uint32_t Impedance;
	float NominalVoltage;
	float Sensibility;
	float Range;
 } __PACKED;

struct MX371x__TransducerInitPrimaryConnectionTest_parameters_t
{
	uint32_t TransducerInitPrimaryConnection;
 } __PACKED;

struct MX371x__TransducerInitPrimaryConnectionTestEx_parameters_t
{
	uint32_t TransducerInitPrimaryConnection;
 } __PACKED;

struct MX371x__TransducerTestPrimaryConnection_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestPrimaryConnectionEx_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestPrimaryShortCircuit_parameters_t
{
	uint32_t ulStatus;
 } __PACKED;

struct MX371x__TransducerTestPrimaryShortCircuitEx_parameters_t
{
	uint32_t ulStatus;
 } __PACKED;

struct MX371x__TransducerRearmPrimary_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerRearmPrimaryEx_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection0_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection0Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection1_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection1Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection2_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection2Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection3_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection3Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection4_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection4Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection5_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection5Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection6_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection6Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection7_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryConnection7Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit0_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit0Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit1_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit1Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit2_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit2Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit3_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit3Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit4_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit4Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit5_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit5Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit6_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit6Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit7_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MX371x__TransducerTestSecondaryShortCircuit7Ex_parameters_t
{
	uint32_t ulValue;
 } __PACKED;

struct MSXE371x__InternalTemperatureRead_parameters_t
{
	float fInternalTemperature;
 } __PACKED;

struct MSXE371x__InternalTemperatureReadEx_parameters_t
{
	float fInternalTemperature;
 } __PACKED;

struct MSXE371x__IncCounterRead32BitValue_parameters_t
{
	uint32_t ulValue;
	uint32_t ulTimeStampLow;
	uint32_t ulTimeStampHigh;
 } __PACKED;

#ifdef WIN32
#pragma pack()
#endif // WIN32



/** <p>Return the number of transducer channels on the module (4,8 or 16)</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <ul>@param[out]<b><VAR>ChannelNumber:</VAR></b> Number of channels</p></ul></ul>
*/
			


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__getNumberOfChannels(struct modbus * modbus,struct MX371x__getNumberOfChannels_parameters_t * Response);



/** <p>Return the number of transducer channels on the module (4,8 or 16)</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <ul>@param[out]<b><VAR>ChannelNumber:</VAR></b> Number of channels</p></ul></ul>
*/
			


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__getNumberOfChannelsEx(struct modbus * modbus,struct MX371x__getNumberOfChannelsEx_parameters_t * Response);



/** <p>This function get the auto refresh counter value an the channels values</p>
*
* <p><b>Parameters:</b></p>
*
* <ul>@param[out]<b><VAR>Value: </VAR></b> Array that contain the counter and channels values \n
* <ul><li> <b>Values [0]:</b> Auto refresh counter value \n
* <li> <b>Values [1]:</b> Channel 0 value \n
* <li> ... \n
* <li> <b>Values [16]:</b> Channel 15 value \n
* </ul></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
* <li> 0 :  means the remote function performed OK \n
* <li> -100 : GetAutoRefreshAllValues kernel function error\n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerGetAutoRefreshValues(struct modbus * modbus,struct MX371x__TransducerGetAutoRefreshValues_parameters_t * Response);



/** <p>This function get the auto refresh counter value an the channels values</p>
*
* <p><b>Parameters:</b></p>
*
* <ul>@param[out]<b><VAR>Value: </VAR></b> Array that contain the counter and channels values \n
* <ul><li> <b>Values [0]:</b> Auto refresh counter value \n
* <li> <b>Values [1]:</b> Channel 0 value \n
* <li> ... \n
* <li> <b>Values [16]:</b> Channel 15 value \n
* </ul></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
* <li> 0 :  means the remote function performed OK \n
* <li> -100 : GetAutoRefreshAllValues kernel function error\n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerGetAutoRefreshValuesEx(struct modbus * modbus,struct MX371x__TransducerGetAutoRefreshValuesEx_parameters_t * Response);



/** <p>Read the external temperature</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[out] <b><VAR>Value:</VAR></b> External temperature value. Format depend from the initialisation</p>
* <p>@param[out] <b><VAR>TimeStampLow:</VAR></b> Time stamp low dword (us)</p>
* <p>@param[out] <b><VAR>TimeStampHigh:</VAR></b> Time stamp high dword (s)</p></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>\n
* <ul>
*                            <li>    0: means the remote function performed OK \n
*                            <li>   -1: means an system error occured \n
*                            <li>   -2: Power save enabled and no transducer acquisition started \n
*                            <li>   -3: Power save enabled and transducer acquisition started but hardware trigger used
*                            <li> -100: Read external temperature kernel function error\n
* </ul>
* </ul>
*/
			


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MSXE371x__ExternalTemperatureRead(struct modbus * modbus,struct MSXE371x__ExternalTemperatureRead_parameters_t * Response);



/** <p>Read the external temperature</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[out] <b><VAR>Value:</VAR></b> External temperature value. Format depend from the initialisation</p>
* <p>@param[out] <b><VAR>TimeStampLow:</VAR></b> Time stamp low dword (us)</p>
* <p>@param[out] <b><VAR>TimeStampHigh:</VAR></b> Time stamp high dword (s)</p></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>\n
* <ul>
*                            <li>    0: means the remote function performed OK \n
*                            <li>   -1: means an system error occured \n
*                            <li>   -2: Power save enabled and no transducer acquisition started \n
*                            <li>   -3: Power save enabled and transducer acquisition started but hardware trigger used
*                            <li> -100: Read external temperature kernel function error\n
* </ul>
* </ul>
*/
			


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MSXE371x__ExternalTemperatureReadEx(struct modbus * modbus,struct MSXE371x__ExternalTemperatureReadEx_parameters_t * Response);



/** <p>Returns the number of transducer types currently defined in the database.</p>
*返回数据库中当前定义的换能器类型的数量。
* <p><b>Parameters:</b></p>
*
* <p>@param[in] <b><VAR>NumberOfTransducerTypes:</VAR></b> number of transducer types currently defined.</p>

* <p><b> Returns:</b></p>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*  <li> 0 : success \n
*  <li> otherwise : internal error\n
* </ul></p></ul>
*/



/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerGetNbrOfType(struct modbus * modbus,struct MX371x__TransducerGetNbrOfType_parameters_t * Response);



/** <p>Returns the number of transducer types currently defined in the database.</p>
*
* <p><b>Parameters:</b></p>
*
* <p>@param[in] <b><VAR>NumberOfTransducerTypes:</VAR></b> number of transducer types currently defined.</p>

* <p><b> Returns:</b></p>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*  <li> 0 : success \n
*  <li> otherwise : internal error\n
* </ul></p></ul>
*/



/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerGetNbrOfTypeEx(struct modbus * modbus,struct MX371x__TransducerGetNbrOfTypeEx_parameters_t * Response);



/** <p>Returns the current cursor of the transducer database.</p>
*
* <p><b>Parameters:</b></p>
*
* <p>@param[in] <b><VAR>TransducerDatabaseCursor:</VAR></b> Current cursor. This is an integer from 0 .. (NumberOfTransducerTypes-1) </p>
*
* <p><b> Returns:</b></p>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*  <li> 0 : success \n
*  <li> otherwise : internal error\n
* </ul></p>
*/



/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__GetTransducerDatabaseCursor(struct modbus * modbus,struct MX371x__GetTransducerDatabaseCursor_parameters_t * Response);



/** <p>Returns the current cursor of the transducer database.</p>
*
* <p><b>Parameters:</b></p>
*
* <p>@param[in] <b><VAR>TransducerDatabaseCursor:</VAR></b> Current cursor. This is an integer from 0 .. (NumberOfTransducerTypes-1) </p>
*
* <p><b> Returns:</b></p>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*  <li> 0 : success \n
*  <li> otherwise : internal error\n
* </ul></p>
*/



/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__GetTransducerDatabaseCursorEx(struct modbus * modbus,struct MX371x__GetTransducerDatabaseCursorEx_parameters_t * Response);



/** <p>Returns the information stored in the database about the type selected by the current TransducerDatabaseCursor.</p>
*
* <p><b>Parameters:</b></p>
*
* <b> <VAR>SelectionIndex :</VAR> </b> Identifier. Value to use for the transducer type selection in the other SOAP functions. \n
* <b> <VAR>Name :</VAR> </b> Name of the transducer type \n
* <b> <VAR>CalibrationStatus :</VAR> </b> Calibration status
*                                    \li 0 : Transducer type is not calibrated \n
*                                    \li 1 : Transducer type is calibrated \n
* <b> <VAR>CalibratedChannels :</VAR> </b>  Bitmask of currently calibrated channels (D0 => channel 1, D1 => channel 1, ...)
* <b> <VAR>Type :</VAR> </b> Type (0: HB 1: LVDT 2:Knaebel 3:HB-Mahr 4:LVDT-Mahr)
*
* <b> <VAR>Frequency :</VAR> </b> Frequency (Hz) \n
* <b> <VAR>Impedance :</VAR> </b> Impedance (Ohm) \n
* <b> <VAR>Veff :</VAR> </b> Nominal voltage (Vrms) \n
* <b> <VAR>Sensibility :</VAR> </b> Sensibility (mv/V/mm)  \n
* <b> <VAR>Range :</VAR> </b> Range (mm) \n
*
* <p><b> Returns:</b></p>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*  <li> 0 : success \n
*  <li> otherwise : internal error\n
* </ul></p></ul>
*/



/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerGetTypeInformation(struct modbus * modbus,struct MX371x__TransducerGetTypeInformation_parameters_t * Response);



/** <p>Returns the information stored in the database about the type selected by the current TransducerDatabaseCursor.</p>
*
* <p><b>Parameters:</b></p>
*
* <b> <VAR>SelectionIndex :</VAR> </b> Identifier. Value to use for the transducer type selection in the other SOAP functions. \n
* <b> <VAR>Name :</VAR> </b> Name of the transducer type \n
* <b> <VAR>CalibrationStatus :</VAR> </b> Calibration status
*                                    \li 0 : Transducer type is not calibrated \n
*                                    \li 1 : Transducer type is calibrated \n
* <b> <VAR>CalibratedChannels :</VAR> </b>  Bitmask of currently calibrated channels (D0 => channel 1, D1 => channel 1, ...)
* <b> <VAR>Type :</VAR> </b> Type (0: HB 1: LVDT 2:Knaebel 3:HB-Mahr 4:LVDT-Mahr)
*
* <b> <VAR>Frequency :</VAR> </b> Frequency (Hz) \n
* <b> <VAR>Impedance :</VAR> </b> Impedance (Ohm) \n
* <b> <VAR>Veff :</VAR> </b> Nominal voltage (Vrms) \n
* <b> <VAR>Sensibility :</VAR> </b> Sensibility (mv/V/mm)  \n
* <b> <VAR>Range :</VAR> </b> Range (mm) \n
*
* <p><b> Returns:</b></p>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*  <li> 0 : success \n
*  <li> otherwise : internal error\n
* </ul></p></ul>
*/



/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerGetTypeInformationEx(struct modbus * modbus,struct MX371x__TransducerGetTypeInformationEx_parameters_t * Response);



/** <p> Initialise the primary connection test </p>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
*				   <li> -100> Primary connection test initialization kernel function error
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerInitPrimaryConnectionTest(struct modbus * modbus,struct MX371x__TransducerInitPrimaryConnectionTest_parameters_t * Response);



/** <p> Initialise the primary connection test </p>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
*				   <li> -100> Primary connection test initialization kernel function error
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerInitPrimaryConnectionTestEx(struct modbus * modbus,struct MX371x__TransducerInitPrimaryConnectionTestEx_parameters_t * Response);



/** <p>Test primary connection </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestPrimaryConnection(struct modbus * modbus,struct MX371x__TransducerTestPrimaryConnection_parameters_t * Response);



/** <p>Test primary connection </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestPrimaryConnectionEx(struct modbus * modbus,struct MX371x__TransducerTestPrimaryConnectionEx_parameters_t * Response);



/** <p>Test primary short circuit </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestPrimaryShortCircuit(struct modbus * modbus,struct MX371x__TransducerTestPrimaryShortCircuit_parameters_t * Response);



/** <p>Test primary short circuit </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestPrimaryShortCircuitEx(struct modbus * modbus,struct MX371x__TransducerTestPrimaryShortCircuitEx_parameters_t * Response);



/** <p>Rearm primary </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Rearm status </p></ul>
* <ul>
*                  <li> 0: Rearm not ok  \n
*                  <li> 1:  Rearm ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerRearmPrimary(struct modbus * modbus,struct MX371x__TransducerRearmPrimary_parameters_t * Response);



/** <p>Rearm primary </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Rearm status </p></ul>
* <ul>
*                  <li> 0: Rearm not ok  \n
*                  <li> 1:  Rearm ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerRearmPrimaryEx(struct modbus * modbus,struct MX371x__TransducerRearmPrimaryEx_parameters_t * Response);



/** <p> Test the secondary connection for channel 0 (you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection0(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection0_parameters_t * Response);



/** <p> Test the secondary connection for channel 0 (you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection0Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection0Ex_parameters_t * Response);



/** <p> Test the secondary connection for channel 1(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection1(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection1_parameters_t * Response);



/** <p> Test the secondary connection for channel 1(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection1Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection1Ex_parameters_t * Response);



/** <p> Test the secondary connection for channel 2(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection2(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection2_parameters_t * Response);



/** <p> Test the secondary connection for channel 2(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection2Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection2Ex_parameters_t * Response);



/** <p> Test the secondary connection for channel 3(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection3(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection3_parameters_t * Response);



/** <p> Test the secondary connection for channel 3(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection3Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection3Ex_parameters_t * Response);



/** <p> Test the secondary connection for channel 4(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection4(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection4_parameters_t * Response);



/** <p> Test the secondary connection for channel 4(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection4Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection4Ex_parameters_t * Response);



/** <p> Test the secondary connection for channel 5(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection5(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection5_parameters_t * Response);



/** <p> Test the secondary connection for channel 5(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection5Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection5Ex_parameters_t * Response);



/** <p> Test the secondary connection for channel 6(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection6(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection6_parameters_t * Response);



/** <p> Test the secondary connection for channel 6(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection6Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection6Ex_parameters_t * Response);



/** <p> Test the secondary connection for channel 7(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection7(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection7_parameters_t * Response);



/** <p> Test the secondary connection for channel 7(you must call the MX371X__TransducerSelectChannel function before to select the channel you want to use ) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> Connection status </p></ul>
* <ul>
*                  <li> 0: connection error  \n
*                  <li> 1:  connection ok \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryConnection7Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryConnection7Ex_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 0(You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit0(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit0_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 0(You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit0Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit0Ex_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 1(You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit1(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit1_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 1(You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit1Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit1Ex_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 2(You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit2(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit2_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 2(You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit2Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit2Ex_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 3 (You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit3(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit3_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 3 (You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit3Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit3Ex_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 4(You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit4(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit4_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 4(You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit4Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit4Ex_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 5(You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit5(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit5_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 5(You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit5Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit5Ex_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 6(You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit6(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit6_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 6(You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit6Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit6Ex_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 7 (You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit7(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit7_parameters_t * Response);



/** <p>Test the secondary short circuit status for channel 7 (You must call the MX371X__TransducerSelectChannel function before to select the channel) </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>ulValue:</VAR></b> short circuit status </p></ul>
* <ul>
*                  <li> 0: short circuit  \n
*                  <li> 1:  no short circuit \n
* </ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MX371x__TransducerTestSecondaryShortCircuit7Ex(struct modbus * modbus,struct MX371x__TransducerTestSecondaryShortCircuit7Ex_parameters_t * Response);



/** <p> Get the MSXE internal temperature in degree </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>fInternalTemperature:</VAR></b> internal temperature in degree </p></ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
    


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MSXE371x__InternalTemperatureRead(struct modbus * modbus,struct MSXE371x__InternalTemperatureRead_parameters_t * Response);



/** <p> Get the MSXE internal temperature in degree </p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[out] <b><VAR>fInternalTemperature:</VAR></b> internal temperature in degree </p></ul>
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
    


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MSXE371x__InternalTemperatureReadEx(struct modbus * modbus,struct MSXE371x__InternalTemperatureReadEx_parameters_t * Response);



/** <p>Read the 32 bits counter value.</p>
*
* <p><b>Parameters:</b></p>
* <ul>
* <p>@param[out] <b><VAR>ulValue</VAR></b> : Counter value.</p>
* <p>@param[out] <b><VAR>ulTimeStampLow</VAR></b> : 32 bit low part of time stamp (us)</p>
* <p>@param[out] <b><VAR>ulTimeStampHigh</VAR></b> : 32 bit high part of time stamp (s)</p>
* </ul>
*
* <ul>
*
* <p><b> Returns:</b></p>
* @return <li><b>Possible return value on the remote system (read them with GetLastCommandStatus):</b>\n
*     <ul>
*                       <li>  0 : No error.
*                       <li> -1 : means an system error occured
*                       <li> -100 : Kernel function error (see syserrno).
*     </ul>
* </ul>
*/
			    


/* @return 0 on success, -1 on system error, -2 on modbus exception, -3 if the received answer is incorrect */
int modbus_call_MSXE371x__IncCounterRead32BitValue(struct modbus * modbus,struct MSXE371x__IncCounterRead32BitValue_parameters_t * Response);


/* Symbolic names for register */
enum {
MX371X__TRANSDUCERINITANDSTARTAUTOREFRESH=1,
MX371X__TRANSDUCERINITANDSTARTAUTOREFRESHEX=1250,
MX371X__TRANSDUCERSTOPANDRELEASEAUTOREFRESH=2,
MX371X__TRANSDUCERSTOPANDRELEASEAUTOREFRESHEX=1300,
MX371X__TRANSDUCERINITANDSTARTSEQUENCE=3,
MX371X__TRANSDUCERINITANDSTARTSEQUENCEEX=1350,
MX371X__TRANSDUCERSTOPANDRELEASESEQUENCE=4,
MX371X__TRANSDUCERSTOPANDRELEASESEQUENCEEX=1400,
MSXE371X__EXTERNALTEMPERATUREINIT=5,
MSXE371X__EXTERNALTEMPERATUREINITEX=1450,
MSXE371X__EXTERNALTEMPERATURERELEASE=6,
MSXE371X__EXTERNALTEMPERATURERELEASEEX=1500,
MX371X__SETTRANSDUCERDATABASECURSOR=7,
MX371X__SETTRANSDUCERDATABASECURSOREX=1504,
MSXE371X__INCCOUNTERINIT=1650,
MSXE371X__INCCOUNTERRELEASE=1700,
MSXE371X__INCCOUNTERCLEAR=1750,
MSXE371X__INCCOUNTERWRITE32BITVALUE=1800,
MSXE371X__INCCOUNTERINITANDENABLECOMPARELOGIC=1850,
MSXE371X__INCCOUNTERDISABLEANDRELEASECOMPARELOGIC=1900,
MSXE371X__INCCOUNTERINITANDENABLEINDEX=2000,
MSXE371X__INCCOUNTERDISABLEANDRELEASEINDEX=2100,
};

#ifdef WIN32
#pragma pack(1)
#endif // WIN32

struct MX371x__TransducerInitAndStartAutoRefresh_parameters_t
{
	uint32_t TransducerSelection;
	uint32_t ChannelMask;
	uint32_t AverageMode;
	uint32_t AverageValue;
	uint32_t TriggerMask;
	uint32_t TriggerMode;
	uint32_t HardwareTriggerEdge;
	uint32_t HardwareTriggerCount;
	uint32_t ByTriggerNbrOfSeqToAcquire;
	uint32_t DataFormat;
	uint32_t Option1;
	uint32_t Option2;
	uint32_t Option3;
	uint32_t Option4;
 } __PACKED;

struct MX371x__TransducerInitAndStartAutoRefreshEx_parameters_t
{
	uint32_t TransducerSelection;
	uint32_t ChannelMask;
	uint32_t AverageMode;
	uint32_t AverageValue;
	uint32_t TriggerMask;
	uint32_t TriggerMode;
	uint32_t HardwareTriggerEdge;
	uint32_t HardwareTriggerCount;
	uint32_t ByTriggerNbrOfSeqToAcquire;
	uint32_t DataFormat;
	uint32_t Option1;
	uint32_t Option2;
	uint32_t Option3;
	uint32_t Option4;
 } __PACKED;

struct MX371x__TransducerStopAndReleaseAutoRefresh_parameters_t
{
	uint32_t Dummy;
 } __PACKED;

struct MX371x__TransducerStopAndReleaseAutoRefreshEx_parameters_t
{
	uint32_t Dummy;
 } __PACKED;

struct MX371x__TransducerInitAndStartSequence_parameters_t
{
	uint32_t TransducerSelection;
	uint32_t NbrOfChannel;
	uint32_t ChannelList[8];
	uint32_t NbrOfSequence;
	uint32_t NbrMaxSequenceToTransfer;
	uint32_t DelayMode;
	uint32_t DelayTimeUnit;
	uint32_t DelayValue;
	uint32_t TriggerMask;
	uint32_t TriggerMode;
	uint32_t HardwareTriggerEdge;
	uint32_t HardwareTriggerCount;
	uint32_t ByTriggerNbrOfSeqToAcquire;
	uint32_t DataFormat;
	uint32_t Option1;
	uint32_t Option2;
	uint32_t Option3;
	uint32_t Option4;
 } __PACKED;

struct MX371x__TransducerInitAndStartSequenceEx_parameters_t
{
	uint32_t TransducerSelection;
	uint32_t NbrOfChannel;
	uint32_t ChannelList[8];
	uint32_t NbrOfSequence;
	uint32_t NbrMaxSequenceToTransfer;
	uint32_t DelayMode;
	uint32_t DelayTimeUnit;
	uint32_t DelayValue;
	uint32_t TriggerMask;
	uint32_t TriggerMode;
	uint32_t HardwareTriggerEdge;
	uint32_t HardwareTriggerCount;
	uint32_t ByTriggerNbrOfSeqToAcquire;
	uint32_t DataFormat;
	uint32_t Option1;
	uint32_t Option2;
	uint32_t Option3;
	uint32_t Option4;
 } __PACKED;

struct MX371x__TransducerStopAndReleaseSequence_parameters_t
{
	uint32_t Dummy;
 } __PACKED;

struct MX371x__TransducerStopAndReleaseSequenceEx_parameters_t
{
	uint32_t Dummy;
 } __PACKED;

struct MSXE371x__ExternalTemperatureInit_parameters_t
{
	uint32_t ConnectedTempSensor;
	uint32_t ConvertMode;
	uint32_t GainSelection;
	uint32_t FrequencySelection;
	uint32_t PowerSaveMode;
	uint32_t Option01;
	uint32_t Option02;
	uint32_t Option03;
	uint32_t Option04;
 } __PACKED;

struct MSXE371x__ExternalTemperatureInitEx_parameters_t
{
	uint32_t ConnectedTempSensor;
	uint32_t ConvertMode;
	uint32_t GainSelection;
	uint32_t FrequencySelection;
	uint32_t PowerSaveMode;
	uint32_t Option01;
	uint32_t Option02;
	uint32_t Option03;
	uint32_t Option04;
 } __PACKED;

struct MSXE371x__ExternalTemperatureRelease_parameters_t
{
	uint32_t Dummy;
 } __PACKED;

struct MSXE371x__ExternalTemperatureReleaseEx_parameters_t
{
	uint32_t Dummy;
 } __PACKED;

struct MX371x__SetTransducerDatabaseCursor_parameters_t
{
	uint32_t TransducerDatabaseCursor;
 } __PACKED;

struct MX371x__SetTransducerDatabaseCursorEx_parameters_t
{
	uint32_t TransducerDatabaseCursor;
 } __PACKED;

struct MSXE371x__IncCounterInit_parameters_t
{
	uint32_t ulCounterMode;
	uint32_t ulCounterOption;
	uint32_t ulOption01;
	uint32_t ulOption02;
	uint32_t ulOption03;
	uint32_t ulOption04;
 } __PACKED;

struct MSXE371x__IncCounterRelease_parameters_t
{
	uint32_t ulOption01;
 } __PACKED;

struct MSXE371x__IncCounterClear_parameters_t
{
	uint32_t ulOption01;
 } __PACKED;

struct MSXE371x__IncCounterWrite32BitValue_parameters_t
{
	uint32_t ulCounterValue;
 } __PACKED;

struct MSXE371x__IncCounterInitAndEnableCompareLogic_parameters_t
{
	uint32_t ulValue;
	uint32_t ulMode;
	uint32_t ulSynchroTrigger;
	uint32_t ulOption01;
	uint32_t ulOption02;
 } __PACKED;

struct MSXE371x__IncCounterDisableAndReleaseCompareLogic_parameters_t
{
	uint32_t ulOption01;
 } __PACKED;

struct MSXE371x__IncCounterInitAndEnableIndex_parameters_t
{
	uint32_t ulReferenceAction;
	uint32_t ulIndexOperation;
	uint32_t ulAutoMode;
	uint32_t ulOption01;
 } __PACKED;

struct MSXE371x__IncCounterDisableAndReleaseIndex_parameters_t
{
	uint32_t ulOption01;
 } __PACKED;

#ifdef WIN32
#pragma pack()
#endif // WIN32


/** <p>Initialise and start the transducer auto refresh acquisition mode</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[in] <b><VAR>TransducerSelection:</VAR></b> Transducer type selection</p>
* <p>@param[in] <b><VAR>ChannelMask:</VAR></b> Mask of the channel to acquire by the auto refresh (1 bit = 1 Channel)</p>
* <p>@param[in] <b><VAR>AverageMode:</VAR></b> Set the average mode : \n
*	<ul>
*                              <li> 0: not used \n
*                              <li> 1: average per channel
*   </ul></p>
* <p>@param[in] <b>AverageValue:</b> Set the average value (only used, when average is used) \n
*	<ul>
*                             <li> 0: average not used \n
*                             <li> max value: 255
*   </ul></p>
* <p>@param[in]  <b>TriggerMask:</b> Define the source of the trigger \n
*	<ul>
*				 	<li> 0 : Trigger disabled \n
*				 	<li> 1 : Enable Hardware Digital Input Trigger \n
*				 	<li> 2 : Enable Synchro Trigger \n
*				 	<li> 4 : Enable Incremental Counter Compare Interrupt \n
*   </ul></p>
*
* <p>@param[in]  <b>TriggerMode:</b> Define the trigger mode \n
*	<ul>
*				 	<li> 1 : One shot trigger : After the software start, the module is waiting for a trigger signal to start the acquisition. After this the trigger signal is ignored.\n
*				 	<li> 2 : Sequence trigger : After the software start the module is waiting for the trigger signal and acquires x sequences (also adjustable) and then wait again. \n
*   </ul></p>
*
* <p>@param[in] <b>HardwareTriggerEdge:</b> Define the edge of hardware who generates a trigger action \n<ul>
*				 	<li> 1 : Rising front (Only if hardware trigger selected) \n
*				 	<li> 2 : Falling front (Only if hardware trigger selected) \n
*				 	<li> 3 : Both front (Only if hardware trigger selected) \n
* 	</ul></p>
*
* <p>@param[in] <b>HardwareTriggerCount:</b> Define the number of trigger events before the action occur \n<ul>
*					<li>0 or 1: all trigger event start the action \n
*					<li>max value: 65535
* 	</ul></p>
*
* <p>@param[in] <b>ByTriggerNbrOfSeqToAcquire:</b> define the number of sequences to acquire by each trigger event</p>
* <p>@param[in] <b>DataFormat:</b> Data format option \n
*				 <ul><li><b> <VAR>D0 : Time stamp information </VAR> </b>\n
*				 <ul>
* 					<li> 0: no time stamp information \n
*				 	<li> 1: time stamp information \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D1 : Data format </VAR> </b>\n
*				 <ul>
* 					<li> 0: Digital value \n
*				 	<li> 1: Analog value (in V) \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D2 : invert value </VAR> </b>\n
*				 <ul>
* 					<li> 0 : don't invert the channel value \n
*				 	<li> 1 : invert the channel value (-2 mm -> + 2mm) \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D3 : Temperature value </VAR> </b>\n
*				 <ul>
* 					<li> 0 : don't acquire the temperature value \n
*				 	<li> 1 : acquire the temperature value \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D4 : Incremental counter value </VAR> </b>\n
*				 <ul>
* 					<li> 0 : don't acquire the incremental counter value \n
*				 	<li> 1 : acquire the incremental counter value \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D5 : Diff. mode </VAR> </b>\n
*				 <ul>
* 					<li> 0 : Diff mode disabled \n
*				 	<li> 1 : Diff mode enabled : Channel X value = Channel (X) value + Channel (X + 4) value \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D5 : Diff. mode </VAR> </b>\n
*				 <ul>
* 					<li> 0 : Diff mode disabled \n
*				 	<li> 1 : Diff mode enabled : Channel X value = Channel (X) value + Channel (X + 4) value \n
*				</ul>
*				</ul><br></p>
*
* <p>@param[in] <b>Option1:</b> Reserved</p>
* <p>@param[in] <b>Option2:</b> Reserved</p>
* <p>@param[in] <b>Option3:</b> Reserved</p>
* <p>@param[in] <b>Option4:</b> Reserved</p>
* </ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*
*                            <li>  0:  means the remote function performed OK \n
*                            <li>  -1:  means an system error occured \n
*                            <li>  -2: Transducer selection error \n
*                            <li>  -3: The channel mask cannot be null \n
*                            <li>  -4: Channel Mask error \n
*                            <li>  -5: not available average mode \n
*                            <li>  -6: not available average value \n
*                            <li>  -7: Trigger source : 2 or more different source cannot be simultaneously be activated \n
*                            <li>  -8: Trigger mode selection error \n
*                            <li>  -9: Hardware trigger : front definition error \n
*                            <li>  -10: Hardware trigger count value not available \n
*                            <li>  -11: Nbr of sequence to acquire by trigger mode not available \n
*                            <li>  -12: Data format not available \n
*                            <li>  -13: Incremental counter not initialised \n
*                            <li>  -14: Incremental counter compare logic not initialised \n
*                            <li>  -15: Temperature channel not initialised \n
*                            <li>  -100: Auto refrseh initialisation and start kernel function error \n
* </ul></ul>
*/
	
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MX371x__TransducerInitAndStartAutoRefresh(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t TransducerSelection;
	uint32_t ChannelMask;
	uint32_t AverageMode;
	uint32_t AverageValue;
	uint32_t TriggerMask;
	uint32_t TriggerMode;
	uint32_t HardwareTriggerEdge;
	uint32_t HardwareTriggerCount;
	uint32_t ByTriggerNbrOfSeqToAcquire;
	uint32_t DataFormat;
	uint32_t Option1;
	uint32_t Option2;
	uint32_t Option3;
	uint32_t Option4;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MX371x__TransducerInitAndStartAutoRefresh(modbus,TransducerSelection,ChannelMask,AverageMode,AverageValue,TriggerMask,TriggerMode,HardwareTriggerEdge,HardwareTriggerCount,ByTriggerNbrOfSeqToAcquire,DataFormat,Option1,Option2,Option3,Option4,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MX371x__TransducerInitAndStartAutoRefresh");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MX371x__TransducerInitAndStartAutoRefresh\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MX371x__TransducerInitAndStartAutoRefresh()\n",ret);
			return -1;
			break;
	}
	printf("call to MX371x__TransducerInitAndStartAutoRefresh OK\n");
	return 0;
}

*/

int modbus_call_MX371x__TransducerInitAndStartAutoRefresh(struct modbus * modbus,
	uint32_t TransducerSelection,
	uint32_t ChannelMask,
	uint32_t AverageMode,
	uint32_t AverageValue,
	uint32_t TriggerMask,
	uint32_t TriggerMode,
	uint32_t HardwareTriggerEdge,
	uint32_t HardwareTriggerCount,
	uint32_t ByTriggerNbrOfSeqToAcquire,
	uint32_t DataFormat,
	uint32_t Option1,
	uint32_t Option2,
	uint32_t Option3,
	uint32_t Option4
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Initialise and start the transducer auto refresh acquisition mode</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[in] <b><VAR>TransducerSelection:</VAR></b> Transducer type selection</p>
* <p>@param[in] <b><VAR>ChannelMask:</VAR></b> Mask of the channel to acquire by the auto refresh (1 bit = 1 Channel)</p>
* <p>@param[in] <b><VAR>AverageMode:</VAR></b> Set the average mode : \n
*	<ul>
*                              <li> 0: not used \n
*                              <li> 1: average per channel
*   </ul></p>
* <p>@param[in] <b>AverageValue:</b> Set the average value (only used, when average is used) \n
*	<ul>
*                             <li> 0: average not used \n
*                             <li> max value: 255
*   </ul></p>
* <p>@param[in]  <b>TriggerMask:</b> Define the source of the trigger \n
*	<ul>
*				 	<li> 0 : Trigger disabled \n
*				 	<li> 1 : Enable Hardware Digital Input Trigger \n
*				 	<li> 2 : Enable Synchro Trigger \n
*				 	<li> 4 : Enable Incremental Counter Compare Interrupt \n
*   </ul></p>
*
* <p>@param[in]  <b>TriggerMode:</b> Define the trigger mode \n
*	<ul>
*				 	<li> 1 : One shot trigger : After the software start, the module is waiting for a trigger signal to start the acquisition. After this the trigger signal is ignored.\n
*				 	<li> 2 : Sequence trigger : After the software start the module is waiting for the trigger signal and acquires x sequences (also adjustable) and then wait again. \n
*   </ul></p>
*
* <p>@param[in] <b>HardwareTriggerEdge:</b> Define the edge of hardware who generates a trigger action \n<ul>
*				 	<li> 1 : Rising front (Only if hardware trigger selected) \n
*				 	<li> 2 : Falling front (Only if hardware trigger selected) \n
*				 	<li> 3 : Both front (Only if hardware trigger selected) \n
* 	</ul></p>
*
* <p>@param[in] <b>HardwareTriggerCount:</b> Define the number of trigger events before the action occur \n<ul>
*					<li>0 or 1: all trigger event start the action \n
*					<li>max value: 65535
* 	</ul></p>
*
* <p>@param[in] <b>ByTriggerNbrOfSeqToAcquire:</b> define the number of sequences to acquire by each trigger event</p>
* <p>@param[in] <b>DataFormat:</b> Data format option \n
*				 <ul><li><b> <VAR>D0 : Time stamp information </VAR> </b>\n
*				 <ul>
* 					<li> 0: no time stamp information \n
*				 	<li> 1: time stamp information \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D1 : Data format </VAR> </b>\n
*				 <ul>
* 					<li> 0: Digital value \n
*				 	<li> 1: Analog value (in V) \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D2 : invert value </VAR> </b>\n
*				 <ul>
* 					<li> 0 : don't invert the channel value \n
*				 	<li> 1 : invert the channel value (-2 mm -> + 2mm) \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D3 : Temperature value </VAR> </b>\n
*				 <ul>
* 					<li> 0 : don't acquire the temperature value \n
*				 	<li> 1 : acquire the temperature value \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D4 : Incremental counter value </VAR> </b>\n
*				 <ul>
* 					<li> 0 : don't acquire the incremental counter value \n
*				 	<li> 1 : acquire the incremental counter value \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D5 : Diff. mode </VAR> </b>\n
*				 <ul>
* 					<li> 0 : Diff mode disabled \n
*				 	<li> 1 : Diff mode enabled : Channel X value = Channel (X) value + Channel (X + 4) value \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D5 : Diff. mode </VAR> </b>\n
*				 <ul>
* 					<li> 0 : Diff mode disabled \n
*				 	<li> 1 : Diff mode enabled : Channel X value = Channel (X) value + Channel (X + 4) value \n
*				</ul>
*				</ul><br></p>
*
* <p>@param[in] <b>Option1:</b> Reserved</p>
* <p>@param[in] <b>Option2:</b> Reserved</p>
* <p>@param[in] <b>Option3:</b> Reserved</p>
* <p>@param[in] <b>Option4:</b> Reserved</p>
* </ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*
*                            <li>  0:  means the remote function performed OK \n
*                            <li>  -1:  means an system error occured \n
*                            <li>  -2: Transducer selection error \n
*                            <li>  -3: The channel mask cannot be null \n
*                            <li>  -4: Channel Mask error \n
*                            <li>  -5: not available average mode \n
*                            <li>  -6: not available average value \n
*                            <li>  -7: Trigger source : 2 or more different source cannot be simultaneously be activated \n
*                            <li>  -8: Trigger mode selection error \n
*                            <li>  -9: Hardware trigger : front definition error \n
*                            <li>  -10: Hardware trigger count value not available \n
*                            <li>  -11: Nbr of sequence to acquire by trigger mode not available \n
*                            <li>  -12: Data format not available \n
*                            <li>  -13: Incremental counter not initialised \n
*                            <li>  -14: Incremental counter compare logic not initialised \n
*                            <li>  -15: Temperature channel not initialised \n
*                            <li>  -100: Auto refrseh initialisation and start kernel function error \n
* </ul></ul>
*/
	
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MX371x__TransducerInitAndStartAutoRefreshEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t TransducerSelection;
	uint32_t ChannelMask;
	uint32_t AverageMode;
	uint32_t AverageValue;
	uint32_t TriggerMask;
	uint32_t TriggerMode;
	uint32_t HardwareTriggerEdge;
	uint32_t HardwareTriggerCount;
	uint32_t ByTriggerNbrOfSeqToAcquire;
	uint32_t DataFormat;
	uint32_t Option1;
	uint32_t Option2;
	uint32_t Option3;
	uint32_t Option4;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MX371x__TransducerInitAndStartAutoRefreshEx(modbus,TransducerSelection,ChannelMask,AverageMode,AverageValue,TriggerMask,TriggerMode,HardwareTriggerEdge,HardwareTriggerCount,ByTriggerNbrOfSeqToAcquire,DataFormat,Option1,Option2,Option3,Option4,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MX371x__TransducerInitAndStartAutoRefreshEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MX371x__TransducerInitAndStartAutoRefreshEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MX371x__TransducerInitAndStartAutoRefreshEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MX371x__TransducerInitAndStartAutoRefreshEx OK\n");
	return 0;
}

*/

int modbus_call_MX371x__TransducerInitAndStartAutoRefreshEx(struct modbus * modbus,
	uint32_t TransducerSelection,
	uint32_t ChannelMask,
	uint32_t AverageMode,
	uint32_t AverageValue,
	uint32_t TriggerMask,
	uint32_t TriggerMode,
	uint32_t HardwareTriggerEdge,
	uint32_t HardwareTriggerCount,
	uint32_t ByTriggerNbrOfSeqToAcquire,
	uint32_t DataFormat,
	uint32_t Option1,
	uint32_t Option2,
	uint32_t Option3,
	uint32_t Option4
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Stop and release the transducer auto refresh acquisition mode</p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[in] <b><VAR>Dummy:</VAR></b> Is not used</p></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
* <li> 0:  means the remote function performed OK \n
* <li> -1:  means an system error occured \n
* <li> -100: StopAutoRefresh kernel function error\n
* </ul></ul></p>
*/
			
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MX371x__TransducerStopAndReleaseAutoRefresh(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t Dummy;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MX371x__TransducerStopAndReleaseAutoRefresh(modbus,Dummy,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MX371x__TransducerStopAndReleaseAutoRefresh");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MX371x__TransducerStopAndReleaseAutoRefresh\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MX371x__TransducerStopAndReleaseAutoRefresh()\n",ret);
			return -1;
			break;
	}
	printf("call to MX371x__TransducerStopAndReleaseAutoRefresh OK\n");
	return 0;
}

*/

int modbus_call_MX371x__TransducerStopAndReleaseAutoRefresh(struct modbus * modbus,
	uint32_t Dummy
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Stop and release the transducer auto refresh acquisition mode</p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[in] <b><VAR>Dummy:</VAR></b> Is not used</p></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
* <li> 0:  means the remote function performed OK \n
* <li> -1:  means an system error occured \n
* <li> -100: StopAutoRefresh kernel function error\n
* </ul></ul></p>
*/
			
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MX371x__TransducerStopAndReleaseAutoRefreshEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t Dummy;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MX371x__TransducerStopAndReleaseAutoRefreshEx(modbus,Dummy,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MX371x__TransducerStopAndReleaseAutoRefreshEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MX371x__TransducerStopAndReleaseAutoRefreshEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MX371x__TransducerStopAndReleaseAutoRefreshEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MX371x__TransducerStopAndReleaseAutoRefreshEx OK\n");
	return 0;
}

*/

int modbus_call_MX371x__TransducerStopAndReleaseAutoRefreshEx(struct modbus * modbus,
	uint32_t Dummy
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Initialise and start the transducer sequence acquisition mode</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[in] <b>TransducerSelection :</b> Transducer type selection</p>
* <p>@param[in] <b>NbrOfChannel :</b> Number of channel in the sequence</p>
* <p>@param[in] <b>ChannelList :</b> List of the channel index (0 to MaxChannel-1) who compose the sequence</p>
* <p>@param[in] <b>NbrOfSequence :</b> Number of sequence to acquire :\n
*	<ul>
*                               <li> 0 : continuous mode \n
*                               <li> > 0 : number of sequence
*
*   </ul></p>
* <p>@param[in] <b>NbrMaxSequenceToTransfer :</b> This parameter defined the minimal number of sequences to acquire between each send of data by the modul.\n
*	<ul>
*                                         Warning : They are two possibilities that the number of sequences sent doesn't reach the minimal number:\n
*                                         <li> By the end of the acquisition.\n
*                                         <li> If the memory capicity is not big enough.
*
*   </ul></p>
* <p>@param[in] <b>DelayMode :</b> Delay Mode : \n
*	<ul>
*                            <li> ADDIDATA_DELAY_NOT_USED	0 : Delay is not used. \n
*                            <li> ADDIDATA_DELAY_MODE1_USED	1 : The delay time defines the time between 2 sequence beginnings.\n
*   </ul></p>
* <p>@param[in] <b>DelayTimeUnit :</b> Selection of the delay time unit \n
*	<ul>
*                               <li> 0: ms   \n
*                               <li> 1: s
*   </ul></p>
* <p>@param[in] <b>DelayValue :</b> Delay Value (max value: 65535) </p>
*
* <p>@param[in]  <b>TriggerMask:</b> Define the source of the trigger \n
*	<ul>
*				 	<li> 0 : Trigger disabled \n
*				 	<li> 1 : Enable Hardware Digital Input Trigger \n
*				 	<li> 2 : Enable Synchro Trigger \n
*				 	<li> 4 : Enable Incremental Counter Compare Interrupt \n
*   </ul></p>
*
* <p>@param[in]  <b>TriggerMode:</b> Define the trigger mode \n
*	<ul>
*				 	<li> 1 : One shot trigger : After the software start, the module is waiting for a trigger signal to start the acquisition. After this the trigger signal is ignored.\n
*				 	<li> 2 : Sequence trigger : After the software start the module is waiting for the trigger signal and acquires x sequences (also adjustable) and then wait again. \n
*   </ul></p>
*
* <p>@param[in] <b>HardwareTriggerEdge:</b> Define the edge of hardware who generates a trigger action \n<ul>
*				 	<li> 1 : Rising front (Only if hardware trigger selected) \n
*				 	<li> 2 : Falling front (Only if hardware trigger selected) \n
*				 	<li> 3 : Both front (Only if hardware trigger selected) \n
* 	</ul></p>
*
* <p>@param[in] <b>HardwareTriggerCount:</b> Define the number of trigger events before the action occur \n<ul>
*					<li>0 or 1: all trigger event start the action \n
*					<li>max value: 65535
* 	</ul></p>
*
* <p>@param[in] <b>ByTriggerNbrOfSeqToAcquire:</b> define the number of sequences to acquire by each trigger event</p>
* <p>@param[in] <b>DataFormat:</b> Data format option \n
*				 <ul><li><b> <VAR>D0 : Time stamp information </VAR> </b>\n
*				 <ul>
* 					<li> 0: no time stamp information \n
*				 	<li> 1: time stamp information \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D1 : Sequence counter information </VAR> </b>\n
*				 <ul>
* 					<li> 0: no sequence counter \n
*				 	<li> 1: sequence counter \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D2 : Data format </VAR> </b>\n
*				 <ul>
* 					<li> 0: Digital value \n
*				 	<li> 1: Analog value (in V) \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D3 : invert value </VAR> </b>\n
*				 <ul>
* 					<li> 0 : don't invert the channel value \n
*				 	<li> 1 : invert the channel value (-2 mm -> + 2mm) \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D4 : Temperature value </VAR> </b>\n
*				 <ul>
* 					<li> 0 : don't acquire the temperature value \n
*				 	<li> 1 : acquire the temperature value \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D5 : Incremental counter value </VAR> </b>\n
*				 <ul>
* 					<li> 0 : don't acquire the incremental counter value \n
*				 	<li> 1 : acquire the incremental counter value \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D6 : Diff. mode </VAR> </b>\n
*				 <ul>
* 					<li> 0 : Diff mode disabled \n
*				 	<li> 1 : Diff mode enabled : Channel X value = Channel (X) value + Channel (X + 4) value \n
*				</ul>
* 				</ul><br>
*
* <p>@param[in] <b>Option1:</b> Reserved</p>
* <p>@param[in] <b>Option2:</b> Reserved</p>
* <p>@param[in] <b>Option3:</b> Reserved</p>
* <p>@param[in] <b>Option4:</b> Reserved</p></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                             <li>  0: means the remote function performed OK \n
*                             <li> -1: means an system error occured \n
*                             <li> -2: Tranducer selection error \n
*                             <li> -3: Number of channel error \n
*                             <li> -4: Channel array selection error \n
*                             <li> -5: Division factor error \n
*                             <li> -6: Incorrect value for Hardware Trigger Mode \n
*                             <li> -7: Incorrect value for Hardware Trigger Front \n
*                             <li> -8: Incorrect value for Synchro Trigger Mode \n
*                             <li> -9: Incorrect value for Hardware Trigger Count \n
*                             <li> -10: Incorrect value for Hardware Trigger filter time \n
*                             <li> -11: Incorrect value for "trigger number of sequences to acquire" \n
*                             <li> -12: Delay Mode selection error \n
*                             <li> -13: Delay time unit selection error \n
*                             <li> -14: Delay value
*                             <li> -15: Wrong data format parameter (Option1) \n
*                             <li> -16: A value for Hardware Trigger front was defined but Hardware Trigger Mode is not set \n
*                             <li> -17: Cannot use both triggers at the same time \n
*						      <li> -18: Incorrect value for the hardware trigger stop front \n
*                             <li> -19: Hardware trigger stop can not be used by this configuration of hardware trigger start\n
*
*                             <li> -100: TransducerInit kernel function error \n
*                             <li> -101: InitConvertTimeDivisionFactor kernel function error \n
*                             <li> -102: InitEnableDisableSequenceDelay kernel function error \n
*                             <li> -103: InitDigitalInputFilter kernel function error \n
*                             <li> -104: InitEnableDisableHardwareTrigger kernel function error \n
*                             <li> -105: InitEnableSynchroTrigger kernel function error \n
*                             <li> -106: DisableSynchroTrigger kernel function error \n
*                             <li> -107: SetTriggerSequenceCount kernel function error \n
*                             <li> -108: InitSequence kernel function error \n
*                             <li> -109: StartStopSequence kernel function error \n
*</ul></ul>
*/
			
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MX371x__TransducerInitAndStartSequence(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t TransducerSelection;
	uint32_t NbrOfChannel;
	uint32_t ChannelList[8];
	uint32_t NbrOfSequence;
	uint32_t NbrMaxSequenceToTransfer;
	uint32_t DelayMode;
	uint32_t DelayTimeUnit;
	uint32_t DelayValue;
	uint32_t TriggerMask;
	uint32_t TriggerMode;
	uint32_t HardwareTriggerEdge;
	uint32_t HardwareTriggerCount;
	uint32_t ByTriggerNbrOfSeqToAcquire;
	uint32_t DataFormat;
	uint32_t Option1;
	uint32_t Option2;
	uint32_t Option3;
	uint32_t Option4;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MX371x__TransducerInitAndStartSequence(modbus,TransducerSelection,NbrOfChannel,ChannelList,NbrOfSequence,NbrMaxSequenceToTransfer,DelayMode,DelayTimeUnit,DelayValue,TriggerMask,TriggerMode,HardwareTriggerEdge,HardwareTriggerCount,ByTriggerNbrOfSeqToAcquire,DataFormat,Option1,Option2,Option3,Option4,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MX371x__TransducerInitAndStartSequence");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MX371x__TransducerInitAndStartSequence\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MX371x__TransducerInitAndStartSequence()\n",ret);
			return -1;
			break;
	}
	printf("call to MX371x__TransducerInitAndStartSequence OK\n");
	return 0;
}

*/

int modbus_call_MX371x__TransducerInitAndStartSequence(struct modbus * modbus,
	uint32_t TransducerSelection,
	uint32_t NbrOfChannel,
	uint32_t ChannelList[8],
	uint32_t NbrOfSequence,
	uint32_t NbrMaxSequenceToTransfer,
	uint32_t DelayMode,
	uint32_t DelayTimeUnit,
	uint32_t DelayValue,
	uint32_t TriggerMask,
	uint32_t TriggerMode,
	uint32_t HardwareTriggerEdge,
	uint32_t HardwareTriggerCount,
	uint32_t ByTriggerNbrOfSeqToAcquire,
	uint32_t DataFormat,
	uint32_t Option1,
	uint32_t Option2,
	uint32_t Option3,
	uint32_t Option4
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Initialise and start the transducer sequence acquisition mode</p>
*
* <p><b>Parameters:</b></p><ul>
*
* <p>@param[in] <b>TransducerSelection :</b> Transducer type selection</p>
* <p>@param[in] <b>NbrOfChannel :</b> Number of channel in the sequence</p>
* <p>@param[in] <b>ChannelList :</b> List of the channel index (0 to MaxChannel-1) who compose the sequence</p>
* <p>@param[in] <b>NbrOfSequence :</b> Number of sequence to acquire :\n
*	<ul>
*                               <li> 0 : continuous mode \n
*                               <li> > 0 : number of sequence
*
*   </ul></p>
* <p>@param[in] <b>NbrMaxSequenceToTransfer :</b> This parameter defined the minimal number of sequences to acquire between each send of data by the modul.\n
*	<ul>
*                                         Warning : They are two possibilities that the number of sequences sent doesn't reach the minimal number:\n
*                                         <li> By the end of the acquisition.\n
*                                         <li> If the memory capicity is not big enough.
*
*   </ul></p>
* <p>@param[in] <b>DelayMode :</b> Delay Mode : \n
*	<ul>
*                            <li> ADDIDATA_DELAY_NOT_USED	0 : Delay is not used. \n
*                            <li> ADDIDATA_DELAY_MODE1_USED	1 : The delay time defines the time between 2 sequence beginnings.\n
*   </ul></p>
* <p>@param[in] <b>DelayTimeUnit :</b> Selection of the delay time unit \n
*	<ul>
*                               <li> 0: ms   \n
*                               <li> 1: s
*   </ul></p>
* <p>@param[in] <b>DelayValue :</b> Delay Value (max value: 65535) </p>
*
* <p>@param[in]  <b>TriggerMask:</b> Define the source of the trigger \n
*	<ul>
*				 	<li> 0 : Trigger disabled \n
*				 	<li> 1 : Enable Hardware Digital Input Trigger \n
*				 	<li> 2 : Enable Synchro Trigger \n
*				 	<li> 4 : Enable Incremental Counter Compare Interrupt \n
*   </ul></p>
*
* <p>@param[in]  <b>TriggerMode:</b> Define the trigger mode \n
*	<ul>
*				 	<li> 1 : One shot trigger : After the software start, the module is waiting for a trigger signal to start the acquisition. After this the trigger signal is ignored.\n
*				 	<li> 2 : Sequence trigger : After the software start the module is waiting for the trigger signal and acquires x sequences (also adjustable) and then wait again. \n
*   </ul></p>
*
* <p>@param[in] <b>HardwareTriggerEdge:</b> Define the edge of hardware who generates a trigger action \n<ul>
*				 	<li> 1 : Rising front (Only if hardware trigger selected) \n
*				 	<li> 2 : Falling front (Only if hardware trigger selected) \n
*				 	<li> 3 : Both front (Only if hardware trigger selected) \n
* 	</ul></p>
*
* <p>@param[in] <b>HardwareTriggerCount:</b> Define the number of trigger events before the action occur \n<ul>
*					<li>0 or 1: all trigger event start the action \n
*					<li>max value: 65535
* 	</ul></p>
*
* <p>@param[in] <b>ByTriggerNbrOfSeqToAcquire:</b> define the number of sequences to acquire by each trigger event</p>
* <p>@param[in] <b>DataFormat:</b> Data format option \n
*				 <ul><li><b> <VAR>D0 : Time stamp information </VAR> </b>\n
*				 <ul>
* 					<li> 0: no time stamp information \n
*				 	<li> 1: time stamp information \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D1 : Sequence counter information </VAR> </b>\n
*				 <ul>
* 					<li> 0: no sequence counter \n
*				 	<li> 1: sequence counter \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D2 : Data format </VAR> </b>\n
*				 <ul>
* 					<li> 0: Digital value \n
*				 	<li> 1: Analog value (in V) \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D3 : invert value </VAR> </b>\n
*				 <ul>
* 					<li> 0 : don't invert the channel value \n
*				 	<li> 1 : invert the channel value (-2 mm -> + 2mm) \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D4 : Temperature value </VAR> </b>\n
*				 <ul>
* 					<li> 0 : don't acquire the temperature value \n
*				 	<li> 1 : acquire the temperature value \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D5 : Incremental counter value </VAR> </b>\n
*				 <ul>
* 					<li> 0 : don't acquire the incremental counter value \n
*				 	<li> 1 : acquire the incremental counter value \n
*				</ul>
* 				</ul><br>
*
*				<ul><li><b> <VAR>D6 : Diff. mode </VAR> </b>\n
*				 <ul>
* 					<li> 0 : Diff mode disabled \n
*				 	<li> 1 : Diff mode enabled : Channel X value = Channel (X) value + Channel (X + 4) value \n
*				</ul>
* 				</ul><br>
*
* <p>@param[in] <b>Option1:</b> Reserved</p>
* <p>@param[in] <b>Option2:</b> Reserved</p>
* <p>@param[in] <b>Option3:</b> Reserved</p>
* <p>@param[in] <b>Option4:</b> Reserved</p></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                             <li>  0: means the remote function performed OK \n
*                             <li> -1: means an system error occured \n
*                             <li> -2: Tranducer selection error \n
*                             <li> -3: Number of channel error \n
*                             <li> -4: Channel array selection error \n
*                             <li> -5: Division factor error \n
*                             <li> -6: Incorrect value for Hardware Trigger Mode \n
*                             <li> -7: Incorrect value for Hardware Trigger Front \n
*                             <li> -8: Incorrect value for Synchro Trigger Mode \n
*                             <li> -9: Incorrect value for Hardware Trigger Count \n
*                             <li> -10: Incorrect value for Hardware Trigger filter time \n
*                             <li> -11: Incorrect value for "trigger number of sequences to acquire" \n
*                             <li> -12: Delay Mode selection error \n
*                             <li> -13: Delay time unit selection error \n
*                             <li> -14: Delay value
*                             <li> -15: Wrong data format parameter (Option1) \n
*                             <li> -16: A value for Hardware Trigger front was defined but Hardware Trigger Mode is not set \n
*                             <li> -17: Cannot use both triggers at the same time \n
*						      <li> -18: Incorrect value for the hardware trigger stop front \n
*                             <li> -19: Hardware trigger stop can not be used by this configuration of hardware trigger start\n
*
*                             <li> -100: TransducerInit kernel function error \n
*                             <li> -101: InitConvertTimeDivisionFactor kernel function error \n
*                             <li> -102: InitEnableDisableSequenceDelay kernel function error \n
*                             <li> -103: InitDigitalInputFilter kernel function error \n
*                             <li> -104: InitEnableDisableHardwareTrigger kernel function error \n
*                             <li> -105: InitEnableSynchroTrigger kernel function error \n
*                             <li> -106: DisableSynchroTrigger kernel function error \n
*                             <li> -107: SetTriggerSequenceCount kernel function error \n
*                             <li> -108: InitSequence kernel function error \n
*                             <li> -109: StartStopSequence kernel function error \n
*</ul></ul>
*/
			
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MX371x__TransducerInitAndStartSequenceEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t TransducerSelection;
	uint32_t NbrOfChannel;
	uint32_t ChannelList[8];
	uint32_t NbrOfSequence;
	uint32_t NbrMaxSequenceToTransfer;
	uint32_t DelayMode;
	uint32_t DelayTimeUnit;
	uint32_t DelayValue;
	uint32_t TriggerMask;
	uint32_t TriggerMode;
	uint32_t HardwareTriggerEdge;
	uint32_t HardwareTriggerCount;
	uint32_t ByTriggerNbrOfSeqToAcquire;
	uint32_t DataFormat;
	uint32_t Option1;
	uint32_t Option2;
	uint32_t Option3;
	uint32_t Option4;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MX371x__TransducerInitAndStartSequenceEx(modbus,TransducerSelection,NbrOfChannel,ChannelList,NbrOfSequence,NbrMaxSequenceToTransfer,DelayMode,DelayTimeUnit,DelayValue,TriggerMask,TriggerMode,HardwareTriggerEdge,HardwareTriggerCount,ByTriggerNbrOfSeqToAcquire,DataFormat,Option1,Option2,Option3,Option4,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MX371x__TransducerInitAndStartSequenceEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MX371x__TransducerInitAndStartSequenceEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MX371x__TransducerInitAndStartSequenceEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MX371x__TransducerInitAndStartSequenceEx OK\n");
	return 0;
}

*/

int modbus_call_MX371x__TransducerInitAndStartSequenceEx(struct modbus * modbus,
	uint32_t TransducerSelection,
	uint32_t NbrOfChannel,
	uint32_t ChannelList[8],
	uint32_t NbrOfSequence,
	uint32_t NbrMaxSequenceToTransfer,
	uint32_t DelayMode,
	uint32_t DelayTimeUnit,
	uint32_t DelayValue,
	uint32_t TriggerMask,
	uint32_t TriggerMode,
	uint32_t HardwareTriggerEdge,
	uint32_t HardwareTriggerCount,
	uint32_t ByTriggerNbrOfSeqToAcquire,
	uint32_t DataFormat,
	uint32_t Option1,
	uint32_t Option2,
	uint32_t Option3,
	uint32_t Option4
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Stop and release the transducer sequence acquisition mode</p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[in] <b><VAR>Dummy:</VAR></b> Is not used</p></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
* <li> 0:  means the remote function performed OK \n
* <li> -1:  means an system error occured \n
* <li> -100: StartStopSequence kernel function error\n
* </ul></ul>
*/
	
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MX371x__TransducerStopAndReleaseSequence(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t Dummy;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MX371x__TransducerStopAndReleaseSequence(modbus,Dummy,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MX371x__TransducerStopAndReleaseSequence");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MX371x__TransducerStopAndReleaseSequence\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MX371x__TransducerStopAndReleaseSequence()\n",ret);
			return -1;
			break;
	}
	printf("call to MX371x__TransducerStopAndReleaseSequence OK\n");
	return 0;
}

*/

int modbus_call_MX371x__TransducerStopAndReleaseSequence(struct modbus * modbus,
	uint32_t Dummy
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Stop and release the transducer sequence acquisition mode</p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[in] <b><VAR>Dummy:</VAR></b> Is not used</p></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
* <li> 0:  means the remote function performed OK \n
* <li> -1:  means an system error occured \n
* <li> -100: StartStopSequence kernel function error\n
* </ul></ul>
*/
	
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MX371x__TransducerStopAndReleaseSequenceEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t Dummy;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MX371x__TransducerStopAndReleaseSequenceEx(modbus,Dummy,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MX371x__TransducerStopAndReleaseSequenceEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MX371x__TransducerStopAndReleaseSequenceEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MX371x__TransducerStopAndReleaseSequenceEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MX371x__TransducerStopAndReleaseSequenceEx OK\n");
	return 0;
}

*/

int modbus_call_MX371x__TransducerStopAndReleaseSequenceEx(struct modbus * modbus,
	uint32_t Dummy
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Initialise the external temperature</p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[in] <b><VAR>ConnectedTempSensor :</VAR></b> Connected sensor type \n
*                              <ul><li> 100 for PT100 \n
*                              <li> 500 for PT500 \n
*                              <li> 1000 for PT1000</ul></p>
* <p>@param[in] <b><VAR>ConvertMode :</VAR></b> Converting mode \n
*                              <ul><li> 0: Disabled. Return the value into the mOhm form \n
*                              <li> 1: oC \n
*                              <li> 2: oF</ul></p>
* <p>@param[in] <b><VAR>GainSelection :</VAR></b> Gain selection (0 for auto mode, 1, 2, 4, 8, 16, 32, 64 or 128)</p>
* <p>@param[in] <b><VAR>FrequencySelection :</VAR></b> Acquisition frequency selection (10, 20, 30, 40, 50, 60, 80, 100, 120, 200, 300, 400, 600, 800, 1200 or 2400)</p>
* <p>@param[in] <b><VAR>PowerSaveMode :</VAR></b> Power save mode selection \n
*                              <ul><li> 0 : Disable the power save mode \n
*                              <li> 1 : Enable the power save mode. Value can only by read if any transducer acquisitions enabled</ul></p>
* <p>@param[in] <b><VAR>Option01 :</VAR></b> Set it to 0</p>
* <p>@param[in] <b><VAR>Option02 :</VAR></b> Set it to 0</p>
* <p>@param[in] <b><VAR>Option03 :</VAR></b> Set it to 0</p>
* <p>@param[in] <b><VAR>Option04 :</VAR></b> Set it to 0</p></ul>

* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                            <li>    0: means the remote function performed OK \n
*                            <li>   -1: means an system error occured \n
*                            <li>   -2: Connected temperature sensor selection error \n
*                            <li>   -3: Convert mode selection error \n
*                            <li>   -4: Gain selection error \n
*                            <li>   -5: Frequency selection error \n
*                            <li>   -6: Power save mode selection error \n
*                            <li> -100: Init external temperature kernel function error \n
* </ul></ul>
*/
	
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MSXE371x__ExternalTemperatureInit(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ConnectedTempSensor;
	uint32_t ConvertMode;
	uint32_t GainSelection;
	uint32_t FrequencySelection;
	uint32_t PowerSaveMode;
	uint32_t Option01;
	uint32_t Option02;
	uint32_t Option03;
	uint32_t Option04;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MSXE371x__ExternalTemperatureInit(modbus,ConnectedTempSensor,ConvertMode,GainSelection,FrequencySelection,PowerSaveMode,Option01,Option02,Option03,Option04,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MSXE371x__ExternalTemperatureInit");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MSXE371x__ExternalTemperatureInit\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MSXE371x__ExternalTemperatureInit()\n",ret);
			return -1;
			break;
	}
	printf("call to MSXE371x__ExternalTemperatureInit OK\n");
	return 0;
}

*/

int modbus_call_MSXE371x__ExternalTemperatureInit(struct modbus * modbus,
	uint32_t ConnectedTempSensor,
	uint32_t ConvertMode,
	uint32_t GainSelection,
	uint32_t FrequencySelection,
	uint32_t PowerSaveMode,
	uint32_t Option01,
	uint32_t Option02,
	uint32_t Option03,
	uint32_t Option04
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Initialise the external temperature</p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[in] <b><VAR>ConnectedTempSensor :</VAR></b> Connected sensor type \n
*                              <ul><li> 100 for PT100 \n
*                              <li> 500 for PT500 \n
*                              <li> 1000 for PT1000</ul></p>
* <p>@param[in] <b><VAR>ConvertMode :</VAR></b> Converting mode \n
*                              <ul><li> 0: Disabled. Return the value into the mOhm form \n
*                              <li> 1: oC \n
*                              <li> 2: oF</ul></p>
* <p>@param[in] <b><VAR>GainSelection :</VAR></b> Gain selection (0 for auto mode, 1, 2, 4, 8, 16, 32, 64 or 128)</p>
* <p>@param[in] <b><VAR>FrequencySelection :</VAR></b> Acquisition frequency selection (10, 20, 30, 40, 50, 60, 80, 100, 120, 200, 300, 400, 600, 800, 1200 or 2400)</p>
* <p>@param[in] <b><VAR>PowerSaveMode :</VAR></b> Power save mode selection \n
*                              <ul><li> 0 : Disable the power save mode \n
*                              <li> 1 : Enable the power save mode. Value can only by read if any transducer acquisitions enabled</ul></p>
* <p>@param[in] <b><VAR>Option01 :</VAR></b> Set it to 0</p>
* <p>@param[in] <b><VAR>Option02 :</VAR></b> Set it to 0</p>
* <p>@param[in] <b><VAR>Option03 :</VAR></b> Set it to 0</p>
* <p>@param[in] <b><VAR>Option04 :</VAR></b> Set it to 0</p></ul>

* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                            <li>    0: means the remote function performed OK \n
*                            <li>   -1: means an system error occured \n
*                            <li>   -2: Connected temperature sensor selection error \n
*                            <li>   -3: Convert mode selection error \n
*                            <li>   -4: Gain selection error \n
*                            <li>   -5: Frequency selection error \n
*                            <li>   -6: Power save mode selection error \n
*                            <li> -100: Init external temperature kernel function error \n
* </ul></ul>
*/
	
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MSXE371x__ExternalTemperatureInitEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ConnectedTempSensor;
	uint32_t ConvertMode;
	uint32_t GainSelection;
	uint32_t FrequencySelection;
	uint32_t PowerSaveMode;
	uint32_t Option01;
	uint32_t Option02;
	uint32_t Option03;
	uint32_t Option04;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MSXE371x__ExternalTemperatureInitEx(modbus,ConnectedTempSensor,ConvertMode,GainSelection,FrequencySelection,PowerSaveMode,Option01,Option02,Option03,Option04,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MSXE371x__ExternalTemperatureInitEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MSXE371x__ExternalTemperatureInitEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MSXE371x__ExternalTemperatureInitEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MSXE371x__ExternalTemperatureInitEx OK\n");
	return 0;
}

*/

int modbus_call_MSXE371x__ExternalTemperatureInitEx(struct modbus * modbus,
	uint32_t ConnectedTempSensor,
	uint32_t ConvertMode,
	uint32_t GainSelection,
	uint32_t FrequencySelection,
	uint32_t PowerSaveMode,
	uint32_t Option01,
	uint32_t Option02,
	uint32_t Option03,
	uint32_t Option04
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Release the external temperature</p>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                            <li>  0: means the remote function performed OK \n
*                            <li> -1: means an system error occured \n</ul></p></ul></ul>
*/
			
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MSXE371x__ExternalTemperatureRelease(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t Dummy;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MSXE371x__ExternalTemperatureRelease(modbus,Dummy,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MSXE371x__ExternalTemperatureRelease");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MSXE371x__ExternalTemperatureRelease\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MSXE371x__ExternalTemperatureRelease()\n",ret);
			return -1;
			break;
	}
	printf("call to MSXE371x__ExternalTemperatureRelease OK\n");
	return 0;
}

*/

int modbus_call_MSXE371x__ExternalTemperatureRelease(struct modbus * modbus,
	uint32_t Dummy
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Release the external temperature</p>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                            <li>  0: means the remote function performed OK \n
*                            <li> -1: means an system error occured \n</ul></p></ul></ul>
*/
			
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MSXE371x__ExternalTemperatureReleaseEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t Dummy;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MSXE371x__ExternalTemperatureReleaseEx(modbus,Dummy,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MSXE371x__ExternalTemperatureReleaseEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MSXE371x__ExternalTemperatureReleaseEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MSXE371x__ExternalTemperatureReleaseEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MSXE371x__ExternalTemperatureReleaseEx OK\n");
	return 0;
}

*/

int modbus_call_MSXE371x__ExternalTemperatureReleaseEx(struct modbus * modbus,
	uint32_t Dummy
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Change the active transducer database cursor</p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[in] <b><VAR>TransducerDatabaseCursor:</VAR></b> New cursor value. This is an integer from 0 .. (NumberOfTransducerTypes-1) </p></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MX371x__SetTransducerDatabaseCursor(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t TransducerDatabaseCursor;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MX371x__SetTransducerDatabaseCursor(modbus,TransducerDatabaseCursor,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MX371x__SetTransducerDatabaseCursor");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MX371x__SetTransducerDatabaseCursor\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MX371x__SetTransducerDatabaseCursor()\n",ret);
			return -1;
			break;
	}
	printf("call to MX371x__SetTransducerDatabaseCursor OK\n");
	return 0;
}

*/

int modbus_call_MX371x__SetTransducerDatabaseCursor(struct modbus * modbus,
	uint32_t TransducerDatabaseCursor
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Change the active transducer database cursor</p>
*
* <p><b>Parameters:</b></p><ul>
* <p>@param[in] <b><VAR>TransducerDatabaseCursor:</VAR></b> New cursor value. This is an integer from 0 .. (NumberOfTransducerTypes-1) </p></ul>
*
* <p><b> Returns:</b></p><ul>
*
* @return <b>Possible return value on the remote system (read them with GetLastCommandStatus)</b>
* <ul>
*                  <li> 0: success \n
*                  <li> -1:  otherwise : internal error \n
* </ul></ul>
*/
	
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MX371x__SetTransducerDatabaseCursorEx(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t TransducerDatabaseCursor;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MX371x__SetTransducerDatabaseCursorEx(modbus,TransducerDatabaseCursor,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MX371x__SetTransducerDatabaseCursorEx");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MX371x__SetTransducerDatabaseCursorEx\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MX371x__SetTransducerDatabaseCursorEx()\n",ret);
			return -1;
			break;
	}
	printf("call to MX371x__SetTransducerDatabaseCursorEx OK\n");
	return 0;
}

*/

int modbus_call_MX371x__SetTransducerDatabaseCursorEx(struct modbus * modbus,
	uint32_t TransducerDatabaseCursor
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** Initialise the counter
*
* <ul>
* @param[in] <li> <b>ulCounterMode</b>  : Set the counter mode : either \n
*	<ul>
*                              <li> MSXE170X_COUNTER_QUADRUPLE_MODE (0x4) \n
*                              <li> MSXE170X_COUNTER_DOUBLE_MODE (0x2) \n
*                              <li> MSXE170X_COUNTER_SIMPLE_MODE (0x1) \n
*                              <li> MSXE170X_COUNTER_DIRECT_MODE (0x0)
*	</ul>
*
* @param[in] <li> <b>ulCounterOption</b> : Set the counter option \n
*                              if in QUADRUPLE/DOUBLE/SIMPLE mode : either \n
*	<ul>
*                             <li> MSXE170X_COUNTER_HYSTERESIS_ON (0x1) \n
*                             <li> MSXE170X_COUNTER_HYSTERESIS_OFF (0x0) \n
*	</ul>
*
*                              if in DIRECT mode : \n
*	<ul>
*                             <li> MSXE170X_COUNTER_INCREMENT (0x0) \n
*                             <li> MSXE170X_COUNTER_DECREMENT (0x1)
*	</ul>
*
* @param[in] <li> <b>ulOption01</b> : Set it to 0
* @param[in] <li> <b>ulOption02</b> : Set it to 0
* @param[in] <li> <b>ulOption03</b> : Set it to 0
* @param[in] <li> <b>ulOption04</b> : Set it to 0
* </ul>
* @param[out] <li><b>Possible return value on the remote system (read them with GetLastCommandStatus):</b>\n
* <ul>
*                            <li>  0: means the remote function performed OK
*                            <li> -1: means an system error occured
*                            <li> -2: Counter mode selection error
*                            <li> -3: Counter option selection error
*                            <li> -100: Init counter kernel function error
* </ul>
*
*/
			    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MSXE371x__IncCounterInit(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulCounterMode;
	uint32_t ulCounterOption;
	uint32_t ulOption01;
	uint32_t ulOption02;
	uint32_t ulOption03;
	uint32_t ulOption04;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MSXE371x__IncCounterInit(modbus,ulCounterMode,ulCounterOption,ulOption01,ulOption02,ulOption03,ulOption04,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MSXE371x__IncCounterInit");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MSXE371x__IncCounterInit\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MSXE371x__IncCounterInit()\n",ret);
			return -1;
			break;
	}
	printf("call to MSXE371x__IncCounterInit OK\n");
	return 0;
}

*/

int modbus_call_MSXE371x__IncCounterInit(struct modbus * modbus,
	uint32_t ulCounterMode,
	uint32_t ulCounterOption,
	uint32_t ulOption01,
	uint32_t ulOption02,
	uint32_t ulOption03,
	uint32_t ulOption04
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** Release the counter
*
* <ul>
* @param[in] <li> <b>ulOption01</b> : Set it to 0
* </ul>
* @param[out] <li><b>Possible return value on the remote system (read them with GetLastCommandStatus):</b>\n
* <ul>
*                            <li>  0: means the remote function performed OK \n
*                            <li> -1: means an system error occured \n
*                            <li> -100: Kernel function error
* </ul>
*
*/
			    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MSXE371x__IncCounterRelease(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulOption01;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MSXE371x__IncCounterRelease(modbus,ulOption01,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MSXE371x__IncCounterRelease");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MSXE371x__IncCounterRelease\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MSXE371x__IncCounterRelease()\n",ret);
			return -1;
			break;
	}
	printf("call to MSXE371x__IncCounterRelease OK\n");
	return 0;
}

*/

int modbus_call_MSXE371x__IncCounterRelease(struct modbus * modbus,
	uint32_t ulOption01
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** Clear the 32 bits counter
*
* <ul>
* @param[in] <li> <b>ulOption01</b> : Set it to 0
* </ul>
* @param[out] <li><b>Possible return value on the remote system (read them with GetLastCommandStatus):</b>
* <ul>
*                            <li>  0: means the remote function performed OK
*                            <li> -1: means an system error occured
*                            <li> -100: Kernel function error
*
* </ul>
*/
			    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MSXE371x__IncCounterClear(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulOption01;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MSXE371x__IncCounterClear(modbus,ulOption01,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MSXE371x__IncCounterClear");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MSXE371x__IncCounterClear\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MSXE371x__IncCounterClear()\n",ret);
			return -1;
			break;
	}
	printf("call to MSXE371x__IncCounterClear OK\n");
	return 0;
}

*/

int modbus_call_MSXE371x__IncCounterClear(struct modbus * modbus,
	uint32_t ulOption01
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** write a 32 bits counter value
*
* <ul>
* @param[in] <li> <b>ulCounterValue</b> : Counter value
* </ul>
* @param[out] <li><b>Possible return value on the remote system (read them with GetLastCommandStatus):</b>\n
* <ul>
*                            <li>  0: means the remote function performed OK
*                            <li> -1: means an system error occured
*                            <li> -2: Counter value error
*                            <li> -100: Kernel function error
* </ul>
*/
			    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MSXE371x__IncCounterWrite32BitValue(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulCounterValue;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MSXE371x__IncCounterWrite32BitValue(modbus,ulCounterValue,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MSXE371x__IncCounterWrite32BitValue");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MSXE371x__IncCounterWrite32BitValue\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MSXE371x__IncCounterWrite32BitValue()\n",ret);
			return -1;
			break;
	}
	printf("call to MSXE371x__IncCounterWrite32BitValue OK\n");
	return 0;
}

*/

int modbus_call_MSXE371x__IncCounterWrite32BitValue(struct modbus * modbus,
	uint32_t ulCounterValue
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Init and enable a counter compare value</p>
*
* <p><b>Parameters:</b></p>
* <ul>
* <p>@param[in] <b><VAR>ulValue / ulValueLow</VAR></b> : compare value (double). ulValueLow</p>
* <p>@param[in] <b><VAR>ulMode</VAR></b> : compare mode \n
*     <ul>
*                                     <li> 0: condition true when counter equals compare value
*                                     <li> 1: condition true when counter equals a multiple of the compare value
*     </ul></p>
* <p>@param[in] <b><VAR>ulSynchroTrigger</VAR></b> \n
*     <ul>
*                                     <li> 0 : no synchro trigger
*                                     <li> 1 : generates a synchro trigger when condition is true
*     </ul></p>
* <p>@param[in] <b><VAR>ulOption01</VAR></b> : set it to 0</p>
* <p>@param[in] <b><VAR>ulOption02</VAR></b> : set it to 0</p>
* </ul>
*
* <ul>
* <p><b> Returns:</b></p>
* @return <li><b>Possible return value on the remote system (read them with GetLastCommandStatus):</b>\n
*     <ul>
*                            <li>  0: means the remote function performed OK
*                            <li> -1: means an system error occured
*                            <li> -2: Compare value error
*                            <li> -3: Compare mode error
*                            <li> -4: Synchro trigger error
*                            <li> -100: Init and enable counter compare kernel function error
*     </ul>
* </ul>
*/
			    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MSXE371x__IncCounterInitAndEnableCompareLogic(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulValue;
	uint32_t ulMode;
	uint32_t ulSynchroTrigger;
	uint32_t ulOption01;
	uint32_t ulOption02;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MSXE371x__IncCounterInitAndEnableCompareLogic(modbus,ulValue,ulMode,ulSynchroTrigger,ulOption01,ulOption02,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MSXE371x__IncCounterInitAndEnableCompareLogic");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MSXE371x__IncCounterInitAndEnableCompareLogic\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MSXE371x__IncCounterInitAndEnableCompareLogic()\n",ret);
			return -1;
			break;
	}
	printf("call to MSXE371x__IncCounterInitAndEnableCompareLogic OK\n");
	return 0;
}

*/

int modbus_call_MSXE371x__IncCounterInitAndEnableCompareLogic(struct modbus * modbus,
	uint32_t ulValue,
	uint32_t ulMode,
	uint32_t ulSynchroTrigger,
	uint32_t ulOption01,
	uint32_t ulOption02
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Disable and Release a counter compare value</p>
*
* <p><b>Parameters:</b></p>
* <ul>
* @param[in] <li> <b>ulOption01</b> : Set it to 0
* </ul>
*
* <ul>
* <p><b> Returns:</b></p>
* @return <li><b>Possible return value on the remote system (read them with GetLastCommandStatus):</b>\n
*     <ul>
*                            <li>  0: means the remote function performed OK
*                            <li> -1: means an system error occured
*                            <li> -100: Disable counter compare value kernel function error
*     </ul>
* </ul>
*/
			    
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MSXE371x__IncCounterDisableAndReleaseCompareLogic(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulOption01;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MSXE371x__IncCounterDisableAndReleaseCompareLogic(modbus,ulOption01,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MSXE371x__IncCounterDisableAndReleaseCompareLogic");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MSXE371x__IncCounterDisableAndReleaseCompareLogic\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MSXE371x__IncCounterDisableAndReleaseCompareLogic()\n",ret);
			return -1;
			break;
	}
	printf("call to MSXE371x__IncCounterDisableAndReleaseCompareLogic OK\n");
	return 0;
}

*/

int modbus_call_MSXE371x__IncCounterDisableAndReleaseCompareLogic(struct modbus * modbus,
	uint32_t ulOption01
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Init and Enable the counter index </p>
*
* <p><b>Parameters:</b></p>
* <ul>
* @param[in] <b>ulReferenceAction</b> : Reference action
*      <ul>
*                                     <li> 0: do not use the pin D as reference
*                                     <li> 1: use the pin D as reference
*     </ul></p>
* @param[in] <b>ulIndexOperation</b> : Index operation
*      <ul>
*                                     <li> 0: latch and clear counter at low edge
*                                     <li> 1: latch and clear counter at high edge
*     </ul></p>
* @param[in] <b>ulAutoMode</b> : Auto mode
*      <ul>
*                                     <li> 0: do not use automode (action is done only once)
*                                     <li> 1: use automode (action is done continuously)
*     </ul></p>
* @param[in] <b>ulOption01</b> : Set it to 0
* </ul>
*
* <ul>
* <p><b> Returns:</b></p>
* @return <li><b>Possible return value on the remote system (read them with GetLastCommandStatus):</b>\n
*     <ul>
*                            <li>  0: Means the remote function performed OK
*                            <li> -1: Means an system error occured
*                            <li> -2: Reference action selection error
*                            <li> -3: Index operation selection error
*                            <li> -4: Automode selection error
*                            <li> -5: Index logic already initialized
*                            <li> -100: Disable counter compare value kernel function error
*     </ul>
* </ul>
*/
                
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MSXE371x__IncCounterInitAndEnableIndex(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulReferenceAction;
	uint32_t ulIndexOperation;
	uint32_t ulAutoMode;
	uint32_t ulOption01;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MSXE371x__IncCounterInitAndEnableIndex(modbus,ulReferenceAction,ulIndexOperation,ulAutoMode,ulOption01,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MSXE371x__IncCounterInitAndEnableIndex");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MSXE371x__IncCounterInitAndEnableIndex\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MSXE371x__IncCounterInitAndEnableIndex()\n",ret);
			return -1;
			break;
	}
	printf("call to MSXE371x__IncCounterInitAndEnableIndex OK\n");
	return 0;
}

*/

int modbus_call_MSXE371x__IncCounterInitAndEnableIndex(struct modbus * modbus,
	uint32_t ulReferenceAction,
	uint32_t ulIndexOperation,
	uint32_t ulAutoMode,
	uint32_t ulOption01
, struct GetLastCommandStatus_parameters_t * CommandStatus);

/** <p>Disable and Release the counter index</p>
*
* <p><b>Parameters:</b></p>
* <ul>
* @param[in] <li> <b>ulOption01</b> : Set it to 0
* </ul>
*
* <ul>
* <p><b> Returns:</b></p>
* @return <li><b>Possible return value on the remote system (read them with GetLastCommandStatus):</b>\n
*     <ul>
*                            <li>  0: Means the remote function performed OK
*                            <li> -1: Means an system error occured
*                            <li> -2: Index logic already initialized
*                            <li> -100: Disable counter compare value kernel function error
*     </ul>
* </ul>
*/
                
/*
@return 0 on success, -1 on system error, -2 on MODBUS exception (the exception code is in modbus->exception), -3 if response from remote system is incorrect, -4 if the remote call generated a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed
*/

/* Below is an example on how this function is intended to be used

int sample_MSXE371x__IncCounterDisableAndReleaseIndex(struct modbus * modbus)
{

	//variables declaration

	struct GetLastCommandStatus_parameters_t CommandStatus;
	int ret = 0;
	uint32_t ulOption01;

	//Initialise variables here

	//Remote function call
	ret = modbus_call_MSXE371x__IncCounterDisableAndReleaseIndex(modbus,ulOption01,&CommandStatus);

	//Return value check
	switch(ret)
	{
		case 0: // OK
			break;
		case -1: // system error
			perror("MSXE371x__IncCounterDisableAndReleaseIndex");
			return -1;
			break;
		case -2: // MODBUS exception
			switch(modbus->exception)
			{
				case MODBUS_REMOTE_EXECUTION_ERROR: // actually a remote exception error and we get it in CommandStatus
					printf("Remote command returned: %d\n",MODBUS_NTOHL((int) (CommandStatus.ReturnValue)) );
					*(CommandStatus.Errstr+sizeof(CommandStatus.Errstr)-1)='\0';
					printf("Remote errno: %d (%s)\n",(int)MODBUS_NTOHL((int)CommandStatus.Syserrno),CommandStatus.Errstr);
					return -1;
					break;
				default:
					printf("remote system returned a MODBUS exception for command MSXE371x__IncCounterDisableAndReleaseIndex\n");
					printf("reason: %s (%d)\n",modbus_exception_to_str(modbus->exception),modbus->exception);
					return -1;
					break;
			}
			break;
		case -3: // incorrect response from remote system
			printf("incorrect response from remote system\n");
			return -1;
			break;
		case -4: 
			printf("remote system returned a MODBUS_REMOTE_EXECUTION_ERROR exception but call to GetLastCommandStatus() failed\n");
			return -1;
			break;
		default: 
			printf("unknown return code %d from MSXE371x__IncCounterDisableAndReleaseIndex()\n",ret);
			return -1;
			break;
	}
	printf("call to MSXE371x__IncCounterDisableAndReleaseIndex OK\n");
	return 0;
}

*/

int modbus_call_MSXE371x__IncCounterDisableAndReleaseIndex(struct modbus * modbus,
	uint32_t ulOption01
, struct GetLastCommandStatus_parameters_t * CommandStatus);

#endif //_MODBUS_MSXE371X_CLIENT_DEFINITION_H_


